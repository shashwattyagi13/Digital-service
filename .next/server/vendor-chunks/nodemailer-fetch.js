"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/nodemailer-fetch";
exports.ids = ["vendor-chunks/nodemailer-fetch"];
exports.modules = {

/***/ "(rsc)/./node_modules/nodemailer-fetch/lib/cookies.js":
/*!******************************************************!*\
  !*** ./node_modules/nodemailer-fetch/lib/cookies.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\n// module to handle cookies\n\nvar urllib = __webpack_require__(/*! url */ \"url\");\n\nvar SESSION_TIMEOUT = 1800; // 30 min\n\nmodule.exports = Cookies;\n\n/**\n * Creates a biskviit cookie jar for managing cookie values in memory\n *\n * @constructor\n * @param {Object} [options] Optional options object\n */\nfunction Cookies(options) {\n    this.options = options || {};\n    this.cookies = [];\n}\n\n/**\n * Stores a cookie string to the cookie storage\n *\n * @param {String} cookieStr Value from the 'Set-Cookie:' header\n * @param {String} url Current URL\n */\nCookies.prototype.set = function (cookieStr, url) {\n    var urlparts = urllib.parse(url || '');\n    var cookie = this.parse(cookieStr);\n    var domain;\n\n    if (cookie.domain) {\n        domain = cookie.domain.replace(/^\\./, '');\n\n        // do not allow cross origin cookies\n        if (\n            // can't be valid if the requested domain is shorter than current hostname\n            urlparts.hostname.length < domain.length ||\n\n            // prefix domains with dot to be sure that partial matches are not used\n            ('.' + urlparts.hostname).substr(-domain.length + 1) !== ('.' + domain)) {\n            cookie.domain = urlparts.hostname;\n        }\n    } else {\n        cookie.domain = urlparts.hostname;\n    }\n\n    if (!cookie.path) {\n        cookie.path = this.getPath(urlparts.pathname);\n    }\n\n    // if no expire date, then use sessionTimeout value\n    if (!cookie.expires) {\n        cookie.expires = new Date(Date.now() + (Number(this.options.sessionTimeout || SESSION_TIMEOUT) || SESSION_TIMEOUT) * 1000);\n    }\n\n    return this.add(cookie);\n};\n\n/**\n * Returns cookie string for the 'Cookie:' header.\n *\n * @param {String} url URL to check for\n * @returns {String} Cookie header or empty string if no matches were found\n */\nCookies.prototype.get = function (url) {\n    return this.list(url).map(function (cookie) {\n        return cookie.name + '=' + cookie.value;\n    }).join('; ');\n};\n\n/**\n * Lists all valied cookie objects for the specified URL\n *\n * @param {String} url URL to check for\n * @returns {Array} An array of cookie objects\n */\nCookies.prototype.list = function (url) {\n    var result = [];\n    var i;\n    var cookie;\n\n    for (i = this.cookies.length - 1; i >= 0; i--) {\n        cookie = this.cookies[i];\n\n        if (this.isExpired(cookie)) {\n            this.cookies.splice(i, i);\n            continue;\n        }\n\n        if (this.match(cookie, url)) {\n            result.unshift(cookie);\n        }\n    }\n\n    return result;\n};\n\n/**\n * Parses cookie string from the 'Set-Cookie:' header\n *\n * @param {String} cookieStr String from the 'Set-Cookie:' header\n * @returns {Object} Cookie object\n */\nCookies.prototype.parse = function (cookieStr) {\n    var cookie = {};\n\n    (cookieStr || '').toString().split(';').forEach(function (cookiePart) {\n        var valueParts = cookiePart.split('=');\n        var key = valueParts.shift().trim().toLowerCase();\n        var value = valueParts.join('=').trim();\n        var domain;\n\n        if (!key) {\n            // skip empty parts\n            return;\n        }\n\n        switch (key) {\n\n            case 'expires':\n                value = new Date(value);\n                // ignore date if can not parse it\n                if (value.toString() !== 'Invalid Date') {\n                    cookie.expires = value;\n                }\n                break;\n\n            case 'path':\n                cookie.path = value;\n                break;\n\n            case 'domain':\n                domain = value.toLowerCase();\n                if (domain.length && domain.charAt(0) !== '.') {\n                    domain = '.' + domain; // ensure preceeding dot for user set domains\n                }\n                cookie.domain = domain;\n                break;\n\n            case 'max-age':\n                cookie.expires = new Date(Date.now() + (Number(value) || 0) * 1000);\n                break;\n\n            case 'secure':\n                cookie.secure = true;\n                break;\n\n            case 'httponly':\n                cookie.httponly = true;\n                break;\n\n            default:\n                if (!cookie.name) {\n                    cookie.name = key;\n                    cookie.value = value;\n                }\n        }\n    });\n\n    return cookie;\n};\n\n/**\n * Checks if a cookie object is valid for a specified URL\n *\n * @param {Object} cookie Cookie object\n * @param {String} url URL to check for\n * @returns {Boolean} true if cookie is valid for specifiec URL\n */\nCookies.prototype.match = function (cookie, url) {\n    var urlparts = urllib.parse(url || '');\n\n    // check if hostname matches\n    // .foo.com also matches subdomains, foo.com does not\n    if (urlparts.hostname !== cookie.domain && (cookie.domain.charAt(0) !== '.' || ('.' + urlparts.hostname).substr(-cookie.domain.length) !== cookie.domain)) {\n        return false;\n    }\n\n    // check if path matches\n    var path = this.getPath(urlparts.pathname);\n    if (path.substr(0, cookie.path.length) !== cookie.path) {\n        return false;\n    }\n\n    // check secure argument\n    if (cookie.secure && urlparts.protocol !== 'https:') {\n        return false;\n    }\n\n    return true;\n};\n\n/**\n * Adds (or updates/removes if needed) a cookie object to the cookie storage\n *\n * @param {Object} cookie Cookie value to be stored\n */\nCookies.prototype.add = function (cookie) {\n    var i;\n    var len;\n\n    // nothing to do here\n    if (!cookie || !cookie.name) {\n        return false;\n    }\n\n    // overwrite if has same params\n    for (i = 0, len = this.cookies.length; i < len; i++) {\n        if (this.compare(this.cookies[i], cookie)) {\n\n            // check if the cookie needs to be removed instead\n            if (this.isExpired(cookie)) {\n                this.cookies.splice(i, 1); // remove expired/unset cookie\n                return false;\n            }\n\n            this.cookies[i] = cookie;\n            return true;\n        }\n    }\n\n    // add as new if not already expired\n    if (!this.isExpired(cookie)) {\n        this.cookies.push(cookie);\n    }\n\n    return true;\n};\n\n/**\n * Checks if two cookie objects are the same\n *\n * @param {Object} a Cookie to check against\n * @param {Object} b Cookie to check against\n * @returns {Boolean} True, if the cookies are the same\n */\nCookies.prototype.compare = function (a, b) {\n    return a.name === b.name && a.path === b.path && a.domain === b.domain && a.secure === b.secure && a.httponly === a.httponly;\n};\n\n/**\n * Checks if a cookie is expired\n *\n * @param {Object} cookie Cookie object to check against\n * @returns {Boolean} True, if the cookie is expired\n */\nCookies.prototype.isExpired = function (cookie) {\n    return (cookie.expires && cookie.expires < new Date()) || !cookie.value;\n};\n\n/**\n * Returns normalized cookie path for an URL path argument\n *\n * @param {String} pathname\n * @returns {String} Normalized path\n */\nCookies.prototype.getPath = function (pathname) {\n    var path = (pathname || '/').split('/');\n    path.pop(); // remove filename part\n    path = path.join('/').trim();\n\n    // ensure path prefix /\n    if (path.charAt(0) !== '/') {\n        path = '/' + path;\n    }\n\n    // ensure path suffix /\n    if (path.substr(-1) !== '/') {\n        path += '/';\n    }\n\n    return path;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm9kZW1haWxlci1mZXRjaC9saWIvY29va2llcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjs7QUFFQSxhQUFhLG1CQUFPLENBQUMsZ0JBQUs7O0FBRTFCLDRCQUE0Qjs7QUFFNUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLFVBQVU7QUFDZjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0NBQXNDLFFBQVE7QUFDOUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQ0FBMkMsU0FBUztBQUNwRDs7QUFFQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tZXRhYnJzLy4vbm9kZV9tb2R1bGVzL25vZGVtYWlsZXItZmV0Y2gvbGliL2Nvb2tpZXMuanM/ZDIxMSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8vIG1vZHVsZSB0byBoYW5kbGUgY29va2llc1xuXG52YXIgdXJsbGliID0gcmVxdWlyZSgndXJsJyk7XG5cbnZhciBTRVNTSU9OX1RJTUVPVVQgPSAxODAwOyAvLyAzMCBtaW5cblxubW9kdWxlLmV4cG9ydHMgPSBDb29raWVzO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBiaXNrdmlpdCBjb29raWUgamFyIGZvciBtYW5hZ2luZyBjb29raWUgdmFsdWVzIGluIG1lbW9yeVxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25hbCBvcHRpb25zIG9iamVjdFxuICovXG5mdW5jdGlvbiBDb29raWVzKG9wdGlvbnMpIHtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIHRoaXMuY29va2llcyA9IFtdO1xufVxuXG4vKipcbiAqIFN0b3JlcyBhIGNvb2tpZSBzdHJpbmcgdG8gdGhlIGNvb2tpZSBzdG9yYWdlXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGNvb2tpZVN0ciBWYWx1ZSBmcm9tIHRoZSAnU2V0LUNvb2tpZTonIGhlYWRlclxuICogQHBhcmFtIHtTdHJpbmd9IHVybCBDdXJyZW50IFVSTFxuICovXG5Db29raWVzLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAoY29va2llU3RyLCB1cmwpIHtcbiAgICB2YXIgdXJscGFydHMgPSB1cmxsaWIucGFyc2UodXJsIHx8ICcnKTtcbiAgICB2YXIgY29va2llID0gdGhpcy5wYXJzZShjb29raWVTdHIpO1xuICAgIHZhciBkb21haW47XG5cbiAgICBpZiAoY29va2llLmRvbWFpbikge1xuICAgICAgICBkb21haW4gPSBjb29raWUuZG9tYWluLnJlcGxhY2UoL15cXC4vLCAnJyk7XG5cbiAgICAgICAgLy8gZG8gbm90IGFsbG93IGNyb3NzIG9yaWdpbiBjb29raWVzXG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIC8vIGNhbid0IGJlIHZhbGlkIGlmIHRoZSByZXF1ZXN0ZWQgZG9tYWluIGlzIHNob3J0ZXIgdGhhbiBjdXJyZW50IGhvc3RuYW1lXG4gICAgICAgICAgICB1cmxwYXJ0cy5ob3N0bmFtZS5sZW5ndGggPCBkb21haW4ubGVuZ3RoIHx8XG5cbiAgICAgICAgICAgIC8vIHByZWZpeCBkb21haW5zIHdpdGggZG90IHRvIGJlIHN1cmUgdGhhdCBwYXJ0aWFsIG1hdGNoZXMgYXJlIG5vdCB1c2VkXG4gICAgICAgICAgICAoJy4nICsgdXJscGFydHMuaG9zdG5hbWUpLnN1YnN0cigtZG9tYWluLmxlbmd0aCArIDEpICE9PSAoJy4nICsgZG9tYWluKSkge1xuICAgICAgICAgICAgY29va2llLmRvbWFpbiA9IHVybHBhcnRzLmhvc3RuYW1lO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgY29va2llLmRvbWFpbiA9IHVybHBhcnRzLmhvc3RuYW1lO1xuICAgIH1cblxuICAgIGlmICghY29va2llLnBhdGgpIHtcbiAgICAgICAgY29va2llLnBhdGggPSB0aGlzLmdldFBhdGgodXJscGFydHMucGF0aG5hbWUpO1xuICAgIH1cblxuICAgIC8vIGlmIG5vIGV4cGlyZSBkYXRlLCB0aGVuIHVzZSBzZXNzaW9uVGltZW91dCB2YWx1ZVxuICAgIGlmICghY29va2llLmV4cGlyZXMpIHtcbiAgICAgICAgY29va2llLmV4cGlyZXMgPSBuZXcgRGF0ZShEYXRlLm5vdygpICsgKE51bWJlcih0aGlzLm9wdGlvbnMuc2Vzc2lvblRpbWVvdXQgfHwgU0VTU0lPTl9USU1FT1VUKSB8fCBTRVNTSU9OX1RJTUVPVVQpICogMTAwMCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuYWRkKGNvb2tpZSk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgY29va2llIHN0cmluZyBmb3IgdGhlICdDb29raWU6JyBoZWFkZXIuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHVybCBVUkwgdG8gY2hlY2sgZm9yXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBDb29raWUgaGVhZGVyIG9yIGVtcHR5IHN0cmluZyBpZiBubyBtYXRjaGVzIHdlcmUgZm91bmRcbiAqL1xuQ29va2llcy5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKHVybCkge1xuICAgIHJldHVybiB0aGlzLmxpc3QodXJsKS5tYXAoZnVuY3Rpb24gKGNvb2tpZSkge1xuICAgICAgICByZXR1cm4gY29va2llLm5hbWUgKyAnPScgKyBjb29raWUudmFsdWU7XG4gICAgfSkuam9pbignOyAnKTtcbn07XG5cbi8qKlxuICogTGlzdHMgYWxsIHZhbGllZCBjb29raWUgb2JqZWN0cyBmb3IgdGhlIHNwZWNpZmllZCBVUkxcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdXJsIFVSTCB0byBjaGVjayBmb3JcbiAqIEByZXR1cm5zIHtBcnJheX0gQW4gYXJyYXkgb2YgY29va2llIG9iamVjdHNcbiAqL1xuQ29va2llcy5wcm90b3R5cGUubGlzdCA9IGZ1bmN0aW9uICh1cmwpIHtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgdmFyIGk7XG4gICAgdmFyIGNvb2tpZTtcblxuICAgIGZvciAoaSA9IHRoaXMuY29va2llcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBjb29raWUgPSB0aGlzLmNvb2tpZXNbaV07XG5cbiAgICAgICAgaWYgKHRoaXMuaXNFeHBpcmVkKGNvb2tpZSkpIHtcbiAgICAgICAgICAgIHRoaXMuY29va2llcy5zcGxpY2UoaSwgaSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLm1hdGNoKGNvb2tpZSwgdXJsKSkge1xuICAgICAgICAgICAgcmVzdWx0LnVuc2hpZnQoY29va2llKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIFBhcnNlcyBjb29raWUgc3RyaW5nIGZyb20gdGhlICdTZXQtQ29va2llOicgaGVhZGVyXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGNvb2tpZVN0ciBTdHJpbmcgZnJvbSB0aGUgJ1NldC1Db29raWU6JyBoZWFkZXJcbiAqIEByZXR1cm5zIHtPYmplY3R9IENvb2tpZSBvYmplY3RcbiAqL1xuQ29va2llcy5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbiAoY29va2llU3RyKSB7XG4gICAgdmFyIGNvb2tpZSA9IHt9O1xuXG4gICAgKGNvb2tpZVN0ciB8fCAnJykudG9TdHJpbmcoKS5zcGxpdCgnOycpLmZvckVhY2goZnVuY3Rpb24gKGNvb2tpZVBhcnQpIHtcbiAgICAgICAgdmFyIHZhbHVlUGFydHMgPSBjb29raWVQYXJ0LnNwbGl0KCc9Jyk7XG4gICAgICAgIHZhciBrZXkgPSB2YWx1ZVBhcnRzLnNoaWZ0KCkudHJpbSgpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHZhciB2YWx1ZSA9IHZhbHVlUGFydHMuam9pbignPScpLnRyaW0oKTtcbiAgICAgICAgdmFyIGRvbWFpbjtcblxuICAgICAgICBpZiAoIWtleSkge1xuICAgICAgICAgICAgLy8gc2tpcCBlbXB0eSBwYXJ0c1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgc3dpdGNoIChrZXkpIHtcblxuICAgICAgICAgICAgY2FzZSAnZXhwaXJlcyc6XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBuZXcgRGF0ZSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgLy8gaWdub3JlIGRhdGUgaWYgY2FuIG5vdCBwYXJzZSBpdFxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZS50b1N0cmluZygpICE9PSAnSW52YWxpZCBEYXRlJykge1xuICAgICAgICAgICAgICAgICAgICBjb29raWUuZXhwaXJlcyA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAncGF0aCc6XG4gICAgICAgICAgICAgICAgY29va2llLnBhdGggPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAnZG9tYWluJzpcbiAgICAgICAgICAgICAgICBkb21haW4gPSB2YWx1ZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgIGlmIChkb21haW4ubGVuZ3RoICYmIGRvbWFpbi5jaGFyQXQoMCkgIT09ICcuJykge1xuICAgICAgICAgICAgICAgICAgICBkb21haW4gPSAnLicgKyBkb21haW47IC8vIGVuc3VyZSBwcmVjZWVkaW5nIGRvdCBmb3IgdXNlciBzZXQgZG9tYWluc1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb29raWUuZG9tYWluID0gZG9tYWluO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlICdtYXgtYWdlJzpcbiAgICAgICAgICAgICAgICBjb29raWUuZXhwaXJlcyA9IG5ldyBEYXRlKERhdGUubm93KCkgKyAoTnVtYmVyKHZhbHVlKSB8fCAwKSAqIDEwMDApO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlICdzZWN1cmUnOlxuICAgICAgICAgICAgICAgIGNvb2tpZS5zZWN1cmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlICdodHRwb25seSc6XG4gICAgICAgICAgICAgICAgY29va2llLmh0dHBvbmx5ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBpZiAoIWNvb2tpZS5uYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvb2tpZS5uYW1lID0ga2V5O1xuICAgICAgICAgICAgICAgICAgICBjb29raWUudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBjb29raWU7XG59O1xuXG4vKipcbiAqIENoZWNrcyBpZiBhIGNvb2tpZSBvYmplY3QgaXMgdmFsaWQgZm9yIGEgc3BlY2lmaWVkIFVSTFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb29raWUgQ29va2llIG9iamVjdFxuICogQHBhcmFtIHtTdHJpbmd9IHVybCBVUkwgdG8gY2hlY2sgZm9yXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gdHJ1ZSBpZiBjb29raWUgaXMgdmFsaWQgZm9yIHNwZWNpZmllYyBVUkxcbiAqL1xuQ29va2llcy5wcm90b3R5cGUubWF0Y2ggPSBmdW5jdGlvbiAoY29va2llLCB1cmwpIHtcbiAgICB2YXIgdXJscGFydHMgPSB1cmxsaWIucGFyc2UodXJsIHx8ICcnKTtcblxuICAgIC8vIGNoZWNrIGlmIGhvc3RuYW1lIG1hdGNoZXNcbiAgICAvLyAuZm9vLmNvbSBhbHNvIG1hdGNoZXMgc3ViZG9tYWlucywgZm9vLmNvbSBkb2VzIG5vdFxuICAgIGlmICh1cmxwYXJ0cy5ob3N0bmFtZSAhPT0gY29va2llLmRvbWFpbiAmJiAoY29va2llLmRvbWFpbi5jaGFyQXQoMCkgIT09ICcuJyB8fCAoJy4nICsgdXJscGFydHMuaG9zdG5hbWUpLnN1YnN0cigtY29va2llLmRvbWFpbi5sZW5ndGgpICE9PSBjb29raWUuZG9tYWluKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gY2hlY2sgaWYgcGF0aCBtYXRjaGVzXG4gICAgdmFyIHBhdGggPSB0aGlzLmdldFBhdGgodXJscGFydHMucGF0aG5hbWUpO1xuICAgIGlmIChwYXRoLnN1YnN0cigwLCBjb29raWUucGF0aC5sZW5ndGgpICE9PSBjb29raWUucGF0aCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gY2hlY2sgc2VjdXJlIGFyZ3VtZW50XG4gICAgaWYgKGNvb2tpZS5zZWN1cmUgJiYgdXJscGFydHMucHJvdG9jb2wgIT09ICdodHRwczonKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8qKlxuICogQWRkcyAob3IgdXBkYXRlcy9yZW1vdmVzIGlmIG5lZWRlZCkgYSBjb29raWUgb2JqZWN0IHRvIHRoZSBjb29raWUgc3RvcmFnZVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb29raWUgQ29va2llIHZhbHVlIHRvIGJlIHN0b3JlZFxuICovXG5Db29raWVzLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAoY29va2llKSB7XG4gICAgdmFyIGk7XG4gICAgdmFyIGxlbjtcblxuICAgIC8vIG5vdGhpbmcgdG8gZG8gaGVyZVxuICAgIGlmICghY29va2llIHx8ICFjb29raWUubmFtZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gb3ZlcndyaXRlIGlmIGhhcyBzYW1lIHBhcmFtc1xuICAgIGZvciAoaSA9IDAsIGxlbiA9IHRoaXMuY29va2llcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBpZiAodGhpcy5jb21wYXJlKHRoaXMuY29va2llc1tpXSwgY29va2llKSkge1xuXG4gICAgICAgICAgICAvLyBjaGVjayBpZiB0aGUgY29va2llIG5lZWRzIHRvIGJlIHJlbW92ZWQgaW5zdGVhZFxuICAgICAgICAgICAgaWYgKHRoaXMuaXNFeHBpcmVkKGNvb2tpZSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvb2tpZXMuc3BsaWNlKGksIDEpOyAvLyByZW1vdmUgZXhwaXJlZC91bnNldCBjb29raWVcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuY29va2llc1tpXSA9IGNvb2tpZTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gYWRkIGFzIG5ldyBpZiBub3QgYWxyZWFkeSBleHBpcmVkXG4gICAgaWYgKCF0aGlzLmlzRXhwaXJlZChjb29raWUpKSB7XG4gICAgICAgIHRoaXMuY29va2llcy5wdXNoKGNvb2tpZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG4vKipcbiAqIENoZWNrcyBpZiB0d28gY29va2llIG9iamVjdHMgYXJlIHRoZSBzYW1lXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGEgQ29va2llIHRvIGNoZWNrIGFnYWluc3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBiIENvb2tpZSB0byBjaGVjayBhZ2FpbnN0XG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSwgaWYgdGhlIGNvb2tpZXMgYXJlIHRoZSBzYW1lXG4gKi9cbkNvb2tpZXMucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiBhLm5hbWUgPT09IGIubmFtZSAmJiBhLnBhdGggPT09IGIucGF0aCAmJiBhLmRvbWFpbiA9PT0gYi5kb21haW4gJiYgYS5zZWN1cmUgPT09IGIuc2VjdXJlICYmIGEuaHR0cG9ubHkgPT09IGEuaHR0cG9ubHk7XG59O1xuXG4vKipcbiAqIENoZWNrcyBpZiBhIGNvb2tpZSBpcyBleHBpcmVkXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGNvb2tpZSBDb29raWUgb2JqZWN0IHRvIGNoZWNrIGFnYWluc3RcbiAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlLCBpZiB0aGUgY29va2llIGlzIGV4cGlyZWRcbiAqL1xuQ29va2llcy5wcm90b3R5cGUuaXNFeHBpcmVkID0gZnVuY3Rpb24gKGNvb2tpZSkge1xuICAgIHJldHVybiAoY29va2llLmV4cGlyZXMgJiYgY29va2llLmV4cGlyZXMgPCBuZXcgRGF0ZSgpKSB8fCAhY29va2llLnZhbHVlO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIG5vcm1hbGl6ZWQgY29va2llIHBhdGggZm9yIGFuIFVSTCBwYXRoIGFyZ3VtZW50XG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHBhdGhuYW1lXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBOb3JtYWxpemVkIHBhdGhcbiAqL1xuQ29va2llcy5wcm90b3R5cGUuZ2V0UGF0aCA9IGZ1bmN0aW9uIChwYXRobmFtZSkge1xuICAgIHZhciBwYXRoID0gKHBhdGhuYW1lIHx8ICcvJykuc3BsaXQoJy8nKTtcbiAgICBwYXRoLnBvcCgpOyAvLyByZW1vdmUgZmlsZW5hbWUgcGFydFxuICAgIHBhdGggPSBwYXRoLmpvaW4oJy8nKS50cmltKCk7XG5cbiAgICAvLyBlbnN1cmUgcGF0aCBwcmVmaXggL1xuICAgIGlmIChwYXRoLmNoYXJBdCgwKSAhPT0gJy8nKSB7XG4gICAgICAgIHBhdGggPSAnLycgKyBwYXRoO1xuICAgIH1cblxuICAgIC8vIGVuc3VyZSBwYXRoIHN1ZmZpeCAvXG4gICAgaWYgKHBhdGguc3Vic3RyKC0xKSAhPT0gJy8nKSB7XG4gICAgICAgIHBhdGggKz0gJy8nO1xuICAgIH1cblxuICAgIHJldHVybiBwYXRoO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/nodemailer-fetch/lib/cookies.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/nodemailer-fetch/lib/fetch.js":
/*!****************************************************!*\
  !*** ./node_modules/nodemailer-fetch/lib/fetch.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nvar http = __webpack_require__(/*! http */ \"http\");\nvar https = __webpack_require__(/*! https */ \"https\");\nvar urllib = __webpack_require__(/*! url */ \"url\");\nvar zlib = __webpack_require__(/*! zlib */ \"zlib\");\nvar PassThrough = (__webpack_require__(/*! stream */ \"stream\").PassThrough);\nvar Cookies = __webpack_require__(/*! ./cookies */ \"(rsc)/./node_modules/nodemailer-fetch/lib/cookies.js\");\n\nvar MAX_REDIRECTS = 5;\n\nmodule.exports = function (url, options) {\n    return fetch(url, options);\n};\n\nmodule.exports.Cookies = Cookies;\n\nfunction fetch(url, options) {\n    options = options || {};\n\n    options.fetchRes = options.fetchRes || new PassThrough();\n    options.cookies = options.cookies || new Cookies();\n    options.redirects = options.redirects || 0;\n    options.maxRedirects = isNaN(options.maxRedirects) ? MAX_REDIRECTS : options.maxRedirects;\n\n    if (options.cookie) {\n        [].concat(options.cookie || []).forEach(function (cookie) {\n            options.cookies.set(cookie, url);\n        });\n        options.cookie = false;\n    }\n\n    var fetchRes = options.fetchRes;\n    var parsed = urllib.parse(url);\n    var method = (options.method || '').toString().trim().toUpperCase() || 'GET';\n    var finished = false;\n    var cookies;\n    var body;\n\n    var handler = parsed.protocol === 'https:' ? https : http;\n\n    var headers = {\n        'accept-encoding': 'gzip,deflate'\n    };\n\n    Object.keys(options.headers || {}).forEach(function (key) {\n        headers[key.toLowerCase().trim()] = options.headers[key];\n    });\n\n    if (options.userAgent) {\n        headers['User-Agent'] = options.userAgent;\n    }\n\n    if (parsed.auth) {\n        headers.Authorization = 'Basic ' + new Buffer(parsed.auth).toString('base64');\n    }\n\n    if ((cookies = options.cookies.get(url))) {\n        headers.cookie = cookies;\n    }\n\n    if (options.body) {\n        if (options.contentType !== false) {\n            headers['Content-Type'] = options.contentType || 'application/x-www-form-urlencoded';\n        }\n\n        if (typeof options.body.pipe === 'function') {\n            // it's a stream\n            headers['Transfer-Encoding'] = 'chunked';\n            body = options.body;\n            body.on('error', function (err) {\n                if (finished) {\n                    return;\n                }\n                finished = true;\n                fetchRes.emit('error', err);\n            });\n        } else {\n            if (options.body instanceof Buffer) {\n                body = options.body;\n            } else if (typeof options.body === 'object') {\n                body = new Buffer(Object.keys(options.body).map(function (key) {\n                    var value = options.body[key].toString().trim();\n                    return encodeURIComponent(key) + '=' + encodeURIComponent(value);\n                }).join('&'));\n            } else {\n                body = new Buffer(options.body.toString().trim());\n            }\n\n            headers['Content-Type'] = options.contentType || 'application/x-www-form-urlencoded';\n            headers['Content-Length'] = body.length;\n        }\n        // if method is not provided, use POST instead of GET\n        method = (options.method || '').toString().trim().toUpperCase() || 'POST';\n    }\n\n    var req;\n    var reqOptions = {\n        method: method,\n        host: parsed.hostname,\n        path: parsed.path,\n        port: parsed.port ? parsed.port : (parsed.protocol === 'https:' ? 443 : 80),\n        headers: headers,\n        rejectUnauthorized: false,\n        agent: false\n    };\n\n    if (options.tls) {\n        Object.keys(options.tls).forEach(function (key) {\n            reqOptions[key] = options.tls[key];\n        });\n    }\n\n    try {\n        req = handler.request(reqOptions);\n    } catch (E) {\n        finished = true;\n        setImmediate(function () {\n            fetchRes.emit('error', E);\n        });\n        return fetchRes;\n    }\n\n    if (options.timeout) {\n        req.setTimeout(options.timeout, function () {\n            if (finished) {\n                return;\n            }\n            finished = true;\n            req.abort();\n            fetchRes.emit('error', new Error('Request Tiemout'));\n        });\n    }\n\n    req.on('error', function (err) {\n        if (finished) {\n            return;\n        }\n        finished = true;\n        fetchRes.emit('error', err);\n    });\n\n    req.on('response', function (res) {\n        var inflate;\n\n        if (finished) {\n            return;\n        }\n\n        switch (res.headers['content-encoding']) {\n            case 'gzip':\n            case 'deflate':\n                inflate = zlib.createUnzip();\n                break;\n        }\n\n        if (res.headers['set-cookie']) {\n            [].concat(res.headers['set-cookie'] || []).forEach(function (cookie) {\n                options.cookies.set(cookie, url);\n            });\n        }\n\n        if ([301, 302, 303, 307, 308].indexOf(res.statusCode) >= 0 && res.headers.location) {\n            // redirect\n            options.redirects++;\n            if (options.redirects > options.maxRedirects) {\n                finished = true;\n                fetchRes.emit('error', new Error('Maximum redirect count exceeded'));\n                req.abort();\n                return;\n            }\n            return fetch(urllib.resolve(url, res.headers.location), options);\n        }\n\n        if (res.statusCode >= 300) {\n            finished = true;\n            fetchRes.emit('error', new Error('Invalid status code ' + res.statusCode));\n            req.abort();\n            return;\n        }\n\n        res.on('error', function (err) {\n            if (finished) {\n                return;\n            }\n            finished = true;\n            fetchRes.emit('error', err);\n            req.abort();\n        });\n\n        if (inflate) {\n            res.pipe(inflate).pipe(fetchRes);\n            inflate.on('error', function (err) {\n                if (finished) {\n                    return;\n                }\n                finished = true;\n                fetchRes.emit('error', err);\n                req.abort();\n            });\n        } else {\n            res.pipe(fetchRes);\n        }\n    });\n\n    setImmediate(function () {\n        if (body) {\n            try {\n                if (typeof body.pipe === 'function') {\n                    return body.pipe(req);\n                } else {\n                    req.write(body);\n                }\n            } catch (err) {\n                finished = true;\n                fetchRes.emit('error', err);\n                return;\n            }\n        }\n        req.end();\n    });\n\n    return fetchRes;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm9kZW1haWxlci1mZXRjaC9saWIvZmV0Y2guanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsV0FBVyxtQkFBTyxDQUFDLGtCQUFNO0FBQ3pCLFlBQVksbUJBQU8sQ0FBQyxvQkFBTztBQUMzQixhQUFhLG1CQUFPLENBQUMsZ0JBQUs7QUFDMUIsV0FBVyxtQkFBTyxDQUFDLGtCQUFNO0FBQ3pCLGtCQUFrQix5REFBNkI7QUFDL0MsY0FBYyxtQkFBTyxDQUFDLHVFQUFXOztBQUVqQzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCOztBQUV0QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEscUNBQXFDO0FBQ3JDO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixVQUFVO0FBQ1Y7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsVUFBVTtBQUNWO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tZXRhYnJzLy4vbm9kZV9tb2R1bGVzL25vZGVtYWlsZXItZmV0Y2gvbGliL2ZldGNoLmpzPzFkYjkiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaHR0cCA9IHJlcXVpcmUoJ2h0dHAnKTtcbnZhciBodHRwcyA9IHJlcXVpcmUoJ2h0dHBzJyk7XG52YXIgdXJsbGliID0gcmVxdWlyZSgndXJsJyk7XG52YXIgemxpYiA9IHJlcXVpcmUoJ3psaWInKTtcbnZhciBQYXNzVGhyb3VnaCA9IHJlcXVpcmUoJ3N0cmVhbScpLlBhc3NUaHJvdWdoO1xudmFyIENvb2tpZXMgPSByZXF1aXJlKCcuL2Nvb2tpZXMnKTtcblxudmFyIE1BWF9SRURJUkVDVFMgPSA1O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh1cmwsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gZmV0Y2godXJsLCBvcHRpb25zKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzLkNvb2tpZXMgPSBDb29raWVzO1xuXG5mdW5jdGlvbiBmZXRjaCh1cmwsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIG9wdGlvbnMuZmV0Y2hSZXMgPSBvcHRpb25zLmZldGNoUmVzIHx8IG5ldyBQYXNzVGhyb3VnaCgpO1xuICAgIG9wdGlvbnMuY29va2llcyA9IG9wdGlvbnMuY29va2llcyB8fCBuZXcgQ29va2llcygpO1xuICAgIG9wdGlvbnMucmVkaXJlY3RzID0gb3B0aW9ucy5yZWRpcmVjdHMgfHwgMDtcbiAgICBvcHRpb25zLm1heFJlZGlyZWN0cyA9IGlzTmFOKG9wdGlvbnMubWF4UmVkaXJlY3RzKSA/IE1BWF9SRURJUkVDVFMgOiBvcHRpb25zLm1heFJlZGlyZWN0cztcblxuICAgIGlmIChvcHRpb25zLmNvb2tpZSkge1xuICAgICAgICBbXS5jb25jYXQob3B0aW9ucy5jb29raWUgfHwgW10pLmZvckVhY2goZnVuY3Rpb24gKGNvb2tpZSkge1xuICAgICAgICAgICAgb3B0aW9ucy5jb29raWVzLnNldChjb29raWUsIHVybCk7XG4gICAgICAgIH0pO1xuICAgICAgICBvcHRpb25zLmNvb2tpZSA9IGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBmZXRjaFJlcyA9IG9wdGlvbnMuZmV0Y2hSZXM7XG4gICAgdmFyIHBhcnNlZCA9IHVybGxpYi5wYXJzZSh1cmwpO1xuICAgIHZhciBtZXRob2QgPSAob3B0aW9ucy5tZXRob2QgfHwgJycpLnRvU3RyaW5nKCkudHJpbSgpLnRvVXBwZXJDYXNlKCkgfHwgJ0dFVCc7XG4gICAgdmFyIGZpbmlzaGVkID0gZmFsc2U7XG4gICAgdmFyIGNvb2tpZXM7XG4gICAgdmFyIGJvZHk7XG5cbiAgICB2YXIgaGFuZGxlciA9IHBhcnNlZC5wcm90b2NvbCA9PT0gJ2h0dHBzOicgPyBodHRwcyA6IGh0dHA7XG5cbiAgICB2YXIgaGVhZGVycyA9IHtcbiAgICAgICAgJ2FjY2VwdC1lbmNvZGluZyc6ICdnemlwLGRlZmxhdGUnXG4gICAgfTtcblxuICAgIE9iamVjdC5rZXlzKG9wdGlvbnMuaGVhZGVycyB8fCB7fSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIGhlYWRlcnNba2V5LnRvTG93ZXJDYXNlKCkudHJpbSgpXSA9IG9wdGlvbnMuaGVhZGVyc1trZXldO1xuICAgIH0pO1xuXG4gICAgaWYgKG9wdGlvbnMudXNlckFnZW50KSB7XG4gICAgICAgIGhlYWRlcnNbJ1VzZXItQWdlbnQnXSA9IG9wdGlvbnMudXNlckFnZW50O1xuICAgIH1cblxuICAgIGlmIChwYXJzZWQuYXV0aCkge1xuICAgICAgICBoZWFkZXJzLkF1dGhvcml6YXRpb24gPSAnQmFzaWMgJyArIG5ldyBCdWZmZXIocGFyc2VkLmF1dGgpLnRvU3RyaW5nKCdiYXNlNjQnKTtcbiAgICB9XG5cbiAgICBpZiAoKGNvb2tpZXMgPSBvcHRpb25zLmNvb2tpZXMuZ2V0KHVybCkpKSB7XG4gICAgICAgIGhlYWRlcnMuY29va2llID0gY29va2llcztcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5ib2R5KSB7XG4gICAgICAgIGlmIChvcHRpb25zLmNvbnRlbnRUeXBlICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgaGVhZGVyc1snQ29udGVudC1UeXBlJ10gPSBvcHRpb25zLmNvbnRlbnRUeXBlIHx8ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLmJvZHkucGlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgLy8gaXQncyBhIHN0cmVhbVxuICAgICAgICAgICAgaGVhZGVyc1snVHJhbnNmZXItRW5jb2RpbmcnXSA9ICdjaHVua2VkJztcbiAgICAgICAgICAgIGJvZHkgPSBvcHRpb25zLmJvZHk7XG4gICAgICAgICAgICBib2R5Lm9uKCdlcnJvcicsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICBpZiAoZmluaXNoZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmaW5pc2hlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgZmV0Y2hSZXMuZW1pdCgnZXJyb3InLCBlcnIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5ib2R5IGluc3RhbmNlb2YgQnVmZmVyKSB7XG4gICAgICAgICAgICAgICAgYm9keSA9IG9wdGlvbnMuYm9keTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG9wdGlvbnMuYm9keSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICBib2R5ID0gbmV3IEJ1ZmZlcihPYmplY3Qua2V5cyhvcHRpb25zLmJvZHkpLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IG9wdGlvbnMuYm9keVtrZXldLnRvU3RyaW5nKCkudHJpbSgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KGtleSkgKyAnPScgKyBlbmNvZGVVUklDb21wb25lbnQodmFsdWUpO1xuICAgICAgICAgICAgICAgIH0pLmpvaW4oJyYnKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGJvZHkgPSBuZXcgQnVmZmVyKG9wdGlvbnMuYm9keS50b1N0cmluZygpLnRyaW0oKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddID0gb3B0aW9ucy5jb250ZW50VHlwZSB8fCAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJztcbiAgICAgICAgICAgIGhlYWRlcnNbJ0NvbnRlbnQtTGVuZ3RoJ10gPSBib2R5Lmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICAvLyBpZiBtZXRob2QgaXMgbm90IHByb3ZpZGVkLCB1c2UgUE9TVCBpbnN0ZWFkIG9mIEdFVFxuICAgICAgICBtZXRob2QgPSAob3B0aW9ucy5tZXRob2QgfHwgJycpLnRvU3RyaW5nKCkudHJpbSgpLnRvVXBwZXJDYXNlKCkgfHwgJ1BPU1QnO1xuICAgIH1cblxuICAgIHZhciByZXE7XG4gICAgdmFyIHJlcU9wdGlvbnMgPSB7XG4gICAgICAgIG1ldGhvZDogbWV0aG9kLFxuICAgICAgICBob3N0OiBwYXJzZWQuaG9zdG5hbWUsXG4gICAgICAgIHBhdGg6IHBhcnNlZC5wYXRoLFxuICAgICAgICBwb3J0OiBwYXJzZWQucG9ydCA/IHBhcnNlZC5wb3J0IDogKHBhcnNlZC5wcm90b2NvbCA9PT0gJ2h0dHBzOicgPyA0NDMgOiA4MCksXG4gICAgICAgIGhlYWRlcnM6IGhlYWRlcnMsXG4gICAgICAgIHJlamVjdFVuYXV0aG9yaXplZDogZmFsc2UsXG4gICAgICAgIGFnZW50OiBmYWxzZVxuICAgIH07XG5cbiAgICBpZiAob3B0aW9ucy50bHMpIHtcbiAgICAgICAgT2JqZWN0LmtleXMob3B0aW9ucy50bHMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgcmVxT3B0aW9uc1trZXldID0gb3B0aW9ucy50bHNba2V5XTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgICAgcmVxID0gaGFuZGxlci5yZXF1ZXN0KHJlcU9wdGlvbnMpO1xuICAgIH0gY2F0Y2ggKEUpIHtcbiAgICAgICAgZmluaXNoZWQgPSB0cnVlO1xuICAgICAgICBzZXRJbW1lZGlhdGUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZmV0Y2hSZXMuZW1pdCgnZXJyb3InLCBFKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBmZXRjaFJlcztcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy50aW1lb3V0KSB7XG4gICAgICAgIHJlcS5zZXRUaW1lb3V0KG9wdGlvbnMudGltZW91dCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKGZpbmlzaGVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluaXNoZWQgPSB0cnVlO1xuICAgICAgICAgICAgcmVxLmFib3J0KCk7XG4gICAgICAgICAgICBmZXRjaFJlcy5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignUmVxdWVzdCBUaWVtb3V0JykpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICByZXEub24oJ2Vycm9yJywgZnVuY3Rpb24gKGVycikge1xuICAgICAgICBpZiAoZmluaXNoZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBmaW5pc2hlZCA9IHRydWU7XG4gICAgICAgIGZldGNoUmVzLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgICB9KTtcblxuICAgIHJlcS5vbigncmVzcG9uc2UnLCBmdW5jdGlvbiAocmVzKSB7XG4gICAgICAgIHZhciBpbmZsYXRlO1xuXG4gICAgICAgIGlmIChmaW5pc2hlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgc3dpdGNoIChyZXMuaGVhZGVyc1snY29udGVudC1lbmNvZGluZyddKSB7XG4gICAgICAgICAgICBjYXNlICdnemlwJzpcbiAgICAgICAgICAgIGNhc2UgJ2RlZmxhdGUnOlxuICAgICAgICAgICAgICAgIGluZmxhdGUgPSB6bGliLmNyZWF0ZVVuemlwKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVzLmhlYWRlcnNbJ3NldC1jb29raWUnXSkge1xuICAgICAgICAgICAgW10uY29uY2F0KHJlcy5oZWFkZXJzWydzZXQtY29va2llJ10gfHwgW10pLmZvckVhY2goZnVuY3Rpb24gKGNvb2tpZSkge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMuY29va2llcy5zZXQoY29va2llLCB1cmwpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoWzMwMSwgMzAyLCAzMDMsIDMwNywgMzA4XS5pbmRleE9mKHJlcy5zdGF0dXNDb2RlKSA+PSAwICYmIHJlcy5oZWFkZXJzLmxvY2F0aW9uKSB7XG4gICAgICAgICAgICAvLyByZWRpcmVjdFxuICAgICAgICAgICAgb3B0aW9ucy5yZWRpcmVjdHMrKztcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnJlZGlyZWN0cyA+IG9wdGlvbnMubWF4UmVkaXJlY3RzKSB7XG4gICAgICAgICAgICAgICAgZmluaXNoZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGZldGNoUmVzLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdNYXhpbXVtIHJlZGlyZWN0IGNvdW50IGV4Y2VlZGVkJykpO1xuICAgICAgICAgICAgICAgIHJlcS5hYm9ydCgpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmZXRjaCh1cmxsaWIucmVzb2x2ZSh1cmwsIHJlcy5oZWFkZXJzLmxvY2F0aW9uKSwgb3B0aW9ucyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVzLnN0YXR1c0NvZGUgPj0gMzAwKSB7XG4gICAgICAgICAgICBmaW5pc2hlZCA9IHRydWU7XG4gICAgICAgICAgICBmZXRjaFJlcy5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignSW52YWxpZCBzdGF0dXMgY29kZSAnICsgcmVzLnN0YXR1c0NvZGUpKTtcbiAgICAgICAgICAgIHJlcS5hYm9ydCgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzLm9uKCdlcnJvcicsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgIGlmIChmaW5pc2hlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGZldGNoUmVzLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgICAgICAgICAgIHJlcS5hYm9ydCgpO1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoaW5mbGF0ZSkge1xuICAgICAgICAgICAgcmVzLnBpcGUoaW5mbGF0ZSkucGlwZShmZXRjaFJlcyk7XG4gICAgICAgICAgICBpbmZsYXRlLm9uKCdlcnJvcicsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICBpZiAoZmluaXNoZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmaW5pc2hlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgZmV0Y2hSZXMuZW1pdCgnZXJyb3InLCBlcnIpO1xuICAgICAgICAgICAgICAgIHJlcS5hYm9ydCgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXMucGlwZShmZXRjaFJlcyk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHNldEltbWVkaWF0ZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChib2R5KSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgYm9keS5waXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBib2R5LnBpcGUocmVxKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXEud3JpdGUoYm9keSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgZmluaXNoZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGZldGNoUmVzLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmVxLmVuZCgpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIGZldGNoUmVzO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/nodemailer-fetch/lib/fetch.js\n");

/***/ })

};
;