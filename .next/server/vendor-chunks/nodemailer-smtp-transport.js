"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/nodemailer-smtp-transport";
exports.ids = ["vendor-chunks/nodemailer-smtp-transport"];
exports.modules = {

/***/ "(rsc)/./node_modules/nodemailer-smtp-transport/lib/smtp-transport.js":
/*!**********************************************************************!*\
  !*** ./node_modules/nodemailer-smtp-transport/lib/smtp-transport.js ***!
  \**********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nvar SMTPConnection = __webpack_require__(/*! smtp-connection */ \"(rsc)/./node_modules/smtp-connection/lib/smtp-connection.js\");\nvar packageData = __webpack_require__(/*! ../package.json */ \"(rsc)/./node_modules/nodemailer-smtp-transport/package.json\");\nvar wellknown = __webpack_require__(/*! nodemailer-wellknown */ \"(rsc)/./node_modules/nodemailer-wellknown/index.js\");\nvar shared = __webpack_require__(/*! nodemailer-shared */ \"(rsc)/./node_modules/nodemailer-shared/lib/shared.js\");\n\nvar EventEmitter = (__webpack_require__(/*! events */ \"events\").EventEmitter);\nvar util = __webpack_require__(/*! util */ \"util\");\n\n// expose to the world\nmodule.exports = function (options) {\n    return new SMTPTransport(options);\n};\n\n/**\n * Creates a SMTP transport object for Nodemailer\n *\n * @constructor\n * @param {Object} options Connection options\n */\nfunction SMTPTransport(options) {\n    EventEmitter.call(this);\n\n    options = options || {};\n    if (typeof options === 'string') {\n        options = {\n            url: options\n        };\n    }\n\n    var urlData;\n    var service = options.service;\n\n    if (typeof options.getSocket === 'function') {\n        this.getSocket = options.getSocket;\n    }\n\n    if (options.url) {\n        urlData = shared.parseConnectionUrl(options.url);\n        service = service || urlData.service;\n    }\n\n    this.options = assign(\n        false, // create new object\n        options, // regular options\n        urlData, // url options\n        service && wellknown(service) // wellknown options\n    );\n\n    this.logger = shared.getLogger(this.options);\n\n    // temporary object\n    var connection = new SMTPConnection(this.options);\n\n    this.name = 'SMTP';\n    this.version = packageData.version + '[client:' + connection.version + ']';\n}\nutil.inherits(SMTPTransport, EventEmitter);\n\n/**\n * Placeholder function for creating proxy sockets. This method immediatelly returns\n * without a socket\n *\n * @param {Object} options Connection options\n * @param {Function} callback Callback function to run with the socket keys\n */\nSMTPTransport.prototype.getSocket = function (options, callback) {\n    // return immediatelly\n    return callback(null, false);\n};\n\n/**\n * Sends an e-mail using the selected settings\n *\n * @param {Object} mail Mail object\n * @param {Function} callback Callback function\n */\nSMTPTransport.prototype.send = function (mail, callback) {\n\n    this.getSocket(this.options, function (err, socketOptions) {\n        if (err) {\n            return callback(err);\n        }\n\n        var options = this.options;\n        if (socketOptions && socketOptions.connection) {\n            this.logger.info('Using proxied socket from %s:%s to %s:%s', socketOptions.connection.remoteAddress, socketOptions.connection.remotePort, options.host || '', options.port || '');\n            // only copy options if we need to modify it\n            options = assign(false, options);\n            Object.keys(socketOptions).forEach(function (key) {\n                options[key] = socketOptions[key];\n            });\n        }\n\n        var connection = new SMTPConnection(options);\n        var returned = false;\n\n        connection.once('error', function (err) {\n            if (returned) {\n                return;\n            }\n            returned = true;\n            connection.close();\n            return callback(err);\n        });\n\n        connection.once('end', function () {\n            if (returned) {\n                return;\n            }\n            returned = true;\n            return callback(new Error('Connection closed'));\n        });\n\n        var sendMessage = function () {\n            var envelope = mail.message.getEnvelope();\n            var messageId = (mail.message.getHeader('message-id') || '').replace(/[<>\\s]/g, '');\n            var recipients = [].concat(envelope.to || []);\n            if (recipients.length > 3) {\n                recipients.push('...and ' + recipients.splice(2).length + ' more');\n            }\n\n            this.logger.info('Sending message <%s> to <%s>', messageId, recipients.join(', '));\n\n            connection.send(envelope, mail.message.createReadStream(), function (err, info) {\n                if (returned) {\n                    return;\n                }\n                returned = true;\n\n                connection.close();\n                if (err) {\n                    return callback(err);\n                }\n                info.envelope = {\n                    from: envelope.from,\n                    to: envelope.to\n                };\n                info.messageId = messageId;\n                return callback(null, info);\n            });\n        }.bind(this);\n\n        connection.connect(function () {\n            if (returned) {\n                return;\n            }\n\n            if (this.options.auth) {\n                connection.login(this.options.auth, function (err) {\n                    if (returned) {\n                        return;\n                    }\n\n                    if (err) {\n                        returned = true;\n                        connection.close();\n                        return callback(err);\n                    }\n\n                    sendMessage();\n                });\n            } else {\n                sendMessage();\n            }\n        }.bind(this));\n    }.bind(this));\n};\n\n/**\n * Verifies SMTP configuration\n *\n * @param {Function} callback Callback function\n */\nSMTPTransport.prototype.verify = function (callback) {\n    var promise;\n\n    if (!callback && typeof Promise === 'function') {\n        promise = new Promise(function (resolve, reject) {\n            callback = shared.callbackPromise(resolve, reject);\n        });\n    }\n\n    this.getSocket(this.options, function (err, socketOptions) {\n        if (err) {\n            return callback(err);\n        }\n\n        var options = this.options;\n        if (socketOptions && socketOptions.connection) {\n            this.logger.info('Using proxied socket from %s:%s', socketOptions.connection.remoteAddress, socketOptions.connection.remotePort);\n            options = assign(false, options);\n            Object.keys(socketOptions).forEach(function (key) {\n                options[key] = socketOptions[key];\n            });\n        }\n\n        var connection = new SMTPConnection(options);\n        var returned = false;\n\n        connection.once('error', function (err) {\n            if (returned) {\n                return;\n            }\n            returned = true;\n            connection.close();\n            return callback(err);\n        });\n\n        connection.once('end', function () {\n            if (returned) {\n                return;\n            }\n            returned = true;\n            return callback(new Error('Connection closed'));\n        });\n\n        var finalize = function () {\n            if (returned) {\n                return;\n            }\n            returned = true;\n            connection.quit();\n            return callback(null, true);\n        };\n\n        connection.connect(function () {\n            if (returned) {\n                return;\n            }\n\n            if (this.options.auth) {\n                connection.login(this.options.auth, function (err) {\n                    if (returned) {\n                        return;\n                    }\n\n                    if (err) {\n                        returned = true;\n                        connection.close();\n                        return callback(err);\n                    }\n\n                    finalize();\n                });\n            } else {\n                finalize();\n            }\n        }.bind(this));\n    }.bind(this));\n\n    return promise;\n};\n\n/**\n * Copies properties from source objects to target objects\n */\nfunction assign( /* target, ... sources */ ) {\n    var args = Array.prototype.slice.call(arguments);\n    var target = args.shift() || {};\n\n    args.forEach(function (source) {\n        Object.keys(source || {}).forEach(function (key) {\n            if (['tls', 'auth'].indexOf(key) >= 0 && source[key] && typeof source[key] === 'object') {\n                // tls and auth are special keys that need to be enumerated separately\n                // other objects are passed as is\n                if (!target[key]) {\n                    // esnure that target has this key\n                    target[key] = {};\n                }\n                Object.keys(source[key]).forEach(function (subKey) {\n                    target[key][subKey] = source[key][subKey];\n                });\n            } else {\n                target[key] = source[key];\n            }\n        });\n    });\n    return target;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbm9kZW1haWxlci1zbXRwLXRyYW5zcG9ydC9saWIvc210cC10cmFuc3BvcnQuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIscUJBQXFCLG1CQUFPLENBQUMsb0ZBQWlCO0FBQzlDLGtCQUFrQixtQkFBTyxDQUFDLG9GQUFpQjtBQUMzQyxnQkFBZ0IsbUJBQU8sQ0FBQyxnRkFBc0I7QUFDOUMsYUFBYSxtQkFBTyxDQUFDLCtFQUFtQjs7QUFFeEMsbUJBQW1CLDBEQUE4QjtBQUNqRCxXQUFXLG1CQUFPLENBQUMsa0JBQU07O0FBRXpCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxVQUFVO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsVUFBVTtBQUNyQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQjtBQUNqQixjQUFjO0FBQ2Q7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUI7QUFDakIsY0FBYztBQUNkO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsY0FBYztBQUNkO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tZXRhYnJzLy4vbm9kZV9tb2R1bGVzL25vZGVtYWlsZXItc210cC10cmFuc3BvcnQvbGliL3NtdHAtdHJhbnNwb3J0LmpzP2Y4NWQiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgU01UUENvbm5lY3Rpb24gPSByZXF1aXJlKCdzbXRwLWNvbm5lY3Rpb24nKTtcbnZhciBwYWNrYWdlRGF0YSA9IHJlcXVpcmUoJy4uL3BhY2thZ2UuanNvbicpO1xudmFyIHdlbGxrbm93biA9IHJlcXVpcmUoJ25vZGVtYWlsZXItd2VsbGtub3duJyk7XG52YXIgc2hhcmVkID0gcmVxdWlyZSgnbm9kZW1haWxlci1zaGFyZWQnKTtcblxudmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcbnZhciB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xuXG4vLyBleHBvc2UgdG8gdGhlIHdvcmxkXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBTTVRQVHJhbnNwb3J0KG9wdGlvbnMpO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgU01UUCB0cmFuc3BvcnQgb2JqZWN0IGZvciBOb2RlbWFpbGVyXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBDb25uZWN0aW9uIG9wdGlvbnNcbiAqL1xuZnVuY3Rpb24gU01UUFRyYW5zcG9ydChvcHRpb25zKSB7XG4gICAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG5cbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIG9wdGlvbnMgPSB7XG4gICAgICAgICAgICB1cmw6IG9wdGlvbnNcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICB2YXIgdXJsRGF0YTtcbiAgICB2YXIgc2VydmljZSA9IG9wdGlvbnMuc2VydmljZTtcblxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5nZXRTb2NrZXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhpcy5nZXRTb2NrZXQgPSBvcHRpb25zLmdldFNvY2tldDtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy51cmwpIHtcbiAgICAgICAgdXJsRGF0YSA9IHNoYXJlZC5wYXJzZUNvbm5lY3Rpb25Vcmwob3B0aW9ucy51cmwpO1xuICAgICAgICBzZXJ2aWNlID0gc2VydmljZSB8fCB1cmxEYXRhLnNlcnZpY2U7XG4gICAgfVxuXG4gICAgdGhpcy5vcHRpb25zID0gYXNzaWduKFxuICAgICAgICBmYWxzZSwgLy8gY3JlYXRlIG5ldyBvYmplY3RcbiAgICAgICAgb3B0aW9ucywgLy8gcmVndWxhciBvcHRpb25zXG4gICAgICAgIHVybERhdGEsIC8vIHVybCBvcHRpb25zXG4gICAgICAgIHNlcnZpY2UgJiYgd2VsbGtub3duKHNlcnZpY2UpIC8vIHdlbGxrbm93biBvcHRpb25zXG4gICAgKTtcblxuICAgIHRoaXMubG9nZ2VyID0gc2hhcmVkLmdldExvZ2dlcih0aGlzLm9wdGlvbnMpO1xuXG4gICAgLy8gdGVtcG9yYXJ5IG9iamVjdFxuICAgIHZhciBjb25uZWN0aW9uID0gbmV3IFNNVFBDb25uZWN0aW9uKHRoaXMub3B0aW9ucyk7XG5cbiAgICB0aGlzLm5hbWUgPSAnU01UUCc7XG4gICAgdGhpcy52ZXJzaW9uID0gcGFja2FnZURhdGEudmVyc2lvbiArICdbY2xpZW50OicgKyBjb25uZWN0aW9uLnZlcnNpb24gKyAnXSc7XG59XG51dGlsLmluaGVyaXRzKFNNVFBUcmFuc3BvcnQsIEV2ZW50RW1pdHRlcik7XG5cbi8qKlxuICogUGxhY2Vob2xkZXIgZnVuY3Rpb24gZm9yIGNyZWF0aW5nIHByb3h5IHNvY2tldHMuIFRoaXMgbWV0aG9kIGltbWVkaWF0ZWxseSByZXR1cm5zXG4gKiB3aXRob3V0IGEgc29ja2V0XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgQ29ubmVjdGlvbiBvcHRpb25zXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFjayBmdW5jdGlvbiB0byBydW4gd2l0aCB0aGUgc29ja2V0IGtleXNcbiAqL1xuU01UUFRyYW5zcG9ydC5wcm90b3R5cGUuZ2V0U29ja2V0ID0gZnVuY3Rpb24gKG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgLy8gcmV0dXJuIGltbWVkaWF0ZWxseVxuICAgIHJldHVybiBjYWxsYmFjayhudWxsLCBmYWxzZSk7XG59O1xuXG4vKipcbiAqIFNlbmRzIGFuIGUtbWFpbCB1c2luZyB0aGUgc2VsZWN0ZWQgc2V0dGluZ3NcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gbWFpbCBNYWlsIG9iamVjdFxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2sgZnVuY3Rpb25cbiAqL1xuU01UUFRyYW5zcG9ydC5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uIChtYWlsLCBjYWxsYmFjaykge1xuXG4gICAgdGhpcy5nZXRTb2NrZXQodGhpcy5vcHRpb25zLCBmdW5jdGlvbiAoZXJyLCBzb2NrZXRPcHRpb25zKSB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgIGlmIChzb2NrZXRPcHRpb25zICYmIHNvY2tldE9wdGlvbnMuY29ubmVjdGlvbikge1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIuaW5mbygnVXNpbmcgcHJveGllZCBzb2NrZXQgZnJvbSAlczolcyB0byAlczolcycsIHNvY2tldE9wdGlvbnMuY29ubmVjdGlvbi5yZW1vdGVBZGRyZXNzLCBzb2NrZXRPcHRpb25zLmNvbm5lY3Rpb24ucmVtb3RlUG9ydCwgb3B0aW9ucy5ob3N0IHx8ICcnLCBvcHRpb25zLnBvcnQgfHwgJycpO1xuICAgICAgICAgICAgLy8gb25seSBjb3B5IG9wdGlvbnMgaWYgd2UgbmVlZCB0byBtb2RpZnkgaXRcbiAgICAgICAgICAgIG9wdGlvbnMgPSBhc3NpZ24oZmFsc2UsIG9wdGlvbnMpO1xuICAgICAgICAgICAgT2JqZWN0LmtleXMoc29ja2V0T3B0aW9ucykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgb3B0aW9uc1trZXldID0gc29ja2V0T3B0aW9uc1trZXldO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY29ubmVjdGlvbiA9IG5ldyBTTVRQQ29ubmVjdGlvbihvcHRpb25zKTtcbiAgICAgICAgdmFyIHJldHVybmVkID0gZmFsc2U7XG5cbiAgICAgICAgY29ubmVjdGlvbi5vbmNlKCdlcnJvcicsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgIGlmIChyZXR1cm5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybmVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvbm5lY3Rpb24uY2xvc2UoKTtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICB9KTtcblxuICAgICAgICBjb25uZWN0aW9uLm9uY2UoJ2VuZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChyZXR1cm5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybmVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhuZXcgRXJyb3IoJ0Nvbm5lY3Rpb24gY2xvc2VkJykpO1xuICAgICAgICB9KTtcblxuICAgICAgICB2YXIgc2VuZE1lc3NhZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgZW52ZWxvcGUgPSBtYWlsLm1lc3NhZ2UuZ2V0RW52ZWxvcGUoKTtcbiAgICAgICAgICAgIHZhciBtZXNzYWdlSWQgPSAobWFpbC5tZXNzYWdlLmdldEhlYWRlcignbWVzc2FnZS1pZCcpIHx8ICcnKS5yZXBsYWNlKC9bPD5cXHNdL2csICcnKTtcbiAgICAgICAgICAgIHZhciByZWNpcGllbnRzID0gW10uY29uY2F0KGVudmVsb3BlLnRvIHx8IFtdKTtcbiAgICAgICAgICAgIGlmIChyZWNpcGllbnRzLmxlbmd0aCA+IDMpIHtcbiAgICAgICAgICAgICAgICByZWNpcGllbnRzLnB1c2goJy4uLmFuZCAnICsgcmVjaXBpZW50cy5zcGxpY2UoMikubGVuZ3RoICsgJyBtb3JlJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLmluZm8oJ1NlbmRpbmcgbWVzc2FnZSA8JXM+IHRvIDwlcz4nLCBtZXNzYWdlSWQsIHJlY2lwaWVudHMuam9pbignLCAnKSk7XG5cbiAgICAgICAgICAgIGNvbm5lY3Rpb24uc2VuZChlbnZlbG9wZSwgbWFpbC5tZXNzYWdlLmNyZWF0ZVJlYWRTdHJlYW0oKSwgZnVuY3Rpb24gKGVyciwgaW5mbykge1xuICAgICAgICAgICAgICAgIGlmIChyZXR1cm5lZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybmVkID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgIGNvbm5lY3Rpb24uY2xvc2UoKTtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpbmZvLmVudmVsb3BlID0ge1xuICAgICAgICAgICAgICAgICAgICBmcm9tOiBlbnZlbG9wZS5mcm9tLFxuICAgICAgICAgICAgICAgICAgICB0bzogZW52ZWxvcGUudG9cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGluZm8ubWVzc2FnZUlkID0gbWVzc2FnZUlkO1xuICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCBpbmZvKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LmJpbmQodGhpcyk7XG5cbiAgICAgICAgY29ubmVjdGlvbi5jb25uZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChyZXR1cm5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5hdXRoKSB7XG4gICAgICAgICAgICAgICAgY29ubmVjdGlvbi5sb2dpbih0aGlzLm9wdGlvbnMuYXV0aCwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgICAgICBpZiAocmV0dXJuZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbm5lY3Rpb24uY2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgc2VuZE1lc3NhZ2UoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc2VuZE1lc3NhZ2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICB9LmJpbmQodGhpcykpO1xufTtcblxuLyoqXG4gKiBWZXJpZmllcyBTTVRQIGNvbmZpZ3VyYXRpb25cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFjayBmdW5jdGlvblxuICovXG5TTVRQVHJhbnNwb3J0LnByb3RvdHlwZS52ZXJpZnkgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICB2YXIgcHJvbWlzZTtcblxuICAgIGlmICghY2FsbGJhY2sgJiYgdHlwZW9mIFByb21pc2UgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrID0gc2hhcmVkLmNhbGxiYWNrUHJvbWlzZShyZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICB0aGlzLmdldFNvY2tldCh0aGlzLm9wdGlvbnMsIGZ1bmN0aW9uIChlcnIsIHNvY2tldE9wdGlvbnMpIHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgaWYgKHNvY2tldE9wdGlvbnMgJiYgc29ja2V0T3B0aW9ucy5jb25uZWN0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLmxvZ2dlci5pbmZvKCdVc2luZyBwcm94aWVkIHNvY2tldCBmcm9tICVzOiVzJywgc29ja2V0T3B0aW9ucy5jb25uZWN0aW9uLnJlbW90ZUFkZHJlc3MsIHNvY2tldE9wdGlvbnMuY29ubmVjdGlvbi5yZW1vdGVQb3J0KTtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBhc3NpZ24oZmFsc2UsIG9wdGlvbnMpO1xuICAgICAgICAgICAgT2JqZWN0LmtleXMoc29ja2V0T3B0aW9ucykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgb3B0aW9uc1trZXldID0gc29ja2V0T3B0aW9uc1trZXldO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY29ubmVjdGlvbiA9IG5ldyBTTVRQQ29ubmVjdGlvbihvcHRpb25zKTtcbiAgICAgICAgdmFyIHJldHVybmVkID0gZmFsc2U7XG5cbiAgICAgICAgY29ubmVjdGlvbi5vbmNlKCdlcnJvcicsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgIGlmIChyZXR1cm5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybmVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvbm5lY3Rpb24uY2xvc2UoKTtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICB9KTtcblxuICAgICAgICBjb25uZWN0aW9uLm9uY2UoJ2VuZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChyZXR1cm5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybmVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhuZXcgRXJyb3IoJ0Nvbm5lY3Rpb24gY2xvc2VkJykpO1xuICAgICAgICB9KTtcblxuICAgICAgICB2YXIgZmluYWxpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAocmV0dXJuZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm5lZCA9IHRydWU7XG4gICAgICAgICAgICBjb25uZWN0aW9uLnF1aXQoKTtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCB0cnVlKTtcbiAgICAgICAgfTtcblxuICAgICAgICBjb25uZWN0aW9uLmNvbm5lY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHJldHVybmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmF1dGgpIHtcbiAgICAgICAgICAgICAgICBjb25uZWN0aW9uLmxvZ2luKHRoaXMub3B0aW9ucy5hdXRoLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXR1cm5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29ubmVjdGlvbi5jbG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBmaW5hbGl6ZSgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBmaW5hbGl6ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgIH0uYmluZCh0aGlzKSk7XG5cbiAgICByZXR1cm4gcHJvbWlzZTtcbn07XG5cbi8qKlxuICogQ29waWVzIHByb3BlcnRpZXMgZnJvbSBzb3VyY2Ugb2JqZWN0cyB0byB0YXJnZXQgb2JqZWN0c1xuICovXG5mdW5jdGlvbiBhc3NpZ24oIC8qIHRhcmdldCwgLi4uIHNvdXJjZXMgKi8gKSB7XG4gICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgIHZhciB0YXJnZXQgPSBhcmdzLnNoaWZ0KCkgfHwge307XG5cbiAgICBhcmdzLmZvckVhY2goZnVuY3Rpb24gKHNvdXJjZSkge1xuICAgICAgICBPYmplY3Qua2V5cyhzb3VyY2UgfHwge30pLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgaWYgKFsndGxzJywgJ2F1dGgnXS5pbmRleE9mKGtleSkgPj0gMCAmJiBzb3VyY2Vba2V5XSAmJiB0eXBlb2Ygc291cmNlW2tleV0gPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgLy8gdGxzIGFuZCBhdXRoIGFyZSBzcGVjaWFsIGtleXMgdGhhdCBuZWVkIHRvIGJlIGVudW1lcmF0ZWQgc2VwYXJhdGVseVxuICAgICAgICAgICAgICAgIC8vIG90aGVyIG9iamVjdHMgYXJlIHBhc3NlZCBhcyBpc1xuICAgICAgICAgICAgICAgIGlmICghdGFyZ2V0W2tleV0pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNudXJlIHRoYXQgdGFyZ2V0IGhhcyB0aGlzIGtleVxuICAgICAgICAgICAgICAgICAgICB0YXJnZXRba2V5XSA9IHt9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhzb3VyY2Vba2V5XSkuZm9yRWFjaChmdW5jdGlvbiAoc3ViS2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldFtrZXldW3N1YktleV0gPSBzb3VyY2Vba2V5XVtzdWJLZXldO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICByZXR1cm4gdGFyZ2V0O1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/nodemailer-smtp-transport/lib/smtp-transport.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/nodemailer-smtp-transport/package.json":
/*!*************************************************************!*\
  !*** ./node_modules/nodemailer-smtp-transport/package.json ***!
  \*************************************************************/
/***/ ((module) => {

module.exports = JSON.parse('{"name":"nodemailer-smtp-transport","version":"2.7.4","description":"SMTP transport for Nodemailer","main":"lib/smtp-transport.js","scripts":{"test":"grunt mochaTest"},"repository":{"type":"git","url":"git://github.com/andris9/nodemailer-smtp-transport.git"},"keywords":["SMTP","Nodemailer"],"author":"Andris Reinman","license":"MIT","bugs":{"url":"https://github.com/andris9/nodemailer-smtp-transport/issues"},"homepage":"http://github.com/andris9/nodemailer-smtp-transport","dependencies":{"nodemailer-shared":"1.1.0","nodemailer-wellknown":"0.1.10","smtp-connection":"2.12.0"},"devDependencies":{"chai":"^3.5.0","grunt":"^1.0.1","grunt-cli":"^1.2.0","grunt-eslint":"^19.0.0","grunt-mocha-test":"^0.12.7","mocha":"^3.0.2","smtp-server":"^1.14.2"}}');

/***/ })

};
;