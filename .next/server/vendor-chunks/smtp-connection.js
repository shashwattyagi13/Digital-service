"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/smtp-connection";
exports.ids = ["vendor-chunks/smtp-connection"];
exports.modules = {

/***/ "(rsc)/./node_modules/smtp-connection/lib/data-stream.js":
/*!*********************************************************!*\
  !*** ./node_modules/smtp-connection/lib/data-stream.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nvar stream = __webpack_require__(/*! stream */ \"stream\");\nvar Transform = stream.Transform;\nvar util = __webpack_require__(/*! util */ \"util\");\n\nmodule.exports = DataStream;\n\n/**\n * Escapes dots in the beginning of lines. Ends the stream with <CR><LF>.<CR><LF>\n * Also makes sure that only <CR><LF> sequences are used for linebreaks\n *\n * @param {Object} options Stream options\n */\nfunction DataStream(options) {\n    // init Transform\n    this.options = options || {};\n    this._curLine = '';\n\n    this.inByteCount = 0;\n    this.outByteCount = 0;\n    this.lastByte = false;\n\n    Transform.call(this, this.options);\n}\nutil.inherits(DataStream, Transform);\n\n/**\n * Escapes dots\n */\nDataStream.prototype._transform = function (chunk, encoding, done) {\n    var chunks = [];\n    var chunklen = 0;\n    var i, len, lastPos = 0;\n    var buf;\n\n    if (!chunk || !chunk.length) {\n        return done();\n    }\n\n    if (typeof chunk === 'string') {\n        chunk = new Buffer(chunk);\n    }\n\n    this.inByteCount += chunk.length;\n\n    for (i = 0, len = chunk.length; i < len; i++) {\n        if (chunk[i] === 0x2E) { // .\n            if (\n                (i && chunk[i - 1] === 0x0A) ||\n                (!i && (!this.lastByte || this.lastByte === 0x0A))\n            ) {\n                buf = chunk.slice(lastPos, i + 1);\n                chunks.push(buf);\n                chunks.push(new Buffer('.'));\n                chunklen += buf.length + 1;\n                lastPos = i + 1;\n            }\n        } else if (chunk[i] === 0x0A) { // .\n            if (\n                (i && chunk[i - 1] !== 0x0D) ||\n                (!i && this.lastByte !== 0x0D)\n            ) {\n                if (i > lastPos) {\n                    buf = chunk.slice(lastPos, i);\n                    chunks.push(buf);\n                    chunklen += buf.length + 2;\n                } else {\n                    chunklen += 2;\n                }\n                chunks.push(new Buffer('\\r\\n'));\n                lastPos = i + 1;\n            }\n        }\n    }\n\n    if (chunklen) {\n        // add last piece\n        if (lastPos < chunk.length) {\n            buf = chunk.slice(lastPos);\n            chunks.push(buf);\n            chunklen += buf.length;\n        }\n\n        this.outByteCount += chunklen;\n        this.push(Buffer.concat(chunks, chunklen));\n    } else {\n        this.outByteCount += chunk.length;\n        this.push(chunk);\n    }\n\n    this.lastByte = chunk[chunk.length - 1];\n    done();\n};\n\n/**\n * Finalizes the stream with a dot on a single line\n */\nDataStream.prototype._flush = function (done) {\n    var buf;\n    if (this.lastByte === 0x0A) {\n        buf = new Buffer('.\\r\\n');\n    } else if (this.lastByte === 0x0D) {\n        buf = new Buffer('\\n.\\r\\n');\n    } else {\n        buf = new Buffer('\\r\\n.\\r\\n');\n    }\n    this.outByteCount += buf.length;\n    this.push(buf);\n    done();\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc210cC1jb25uZWN0aW9uL2xpYi9kYXRhLXN0cmVhbS5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixhQUFhLG1CQUFPLENBQUMsc0JBQVE7QUFDN0I7QUFDQSxXQUFXLG1CQUFPLENBQUMsa0JBQU07O0FBRXpCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsb0NBQW9DLFNBQVM7QUFDN0MsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSw4QkFBOEI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbWV0YWJycy8uL25vZGVfbW9kdWxlcy9zbXRwLWNvbm5lY3Rpb24vbGliL2RhdGEtc3RyZWFtLmpzPzAyNDgiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgc3RyZWFtID0gcmVxdWlyZSgnc3RyZWFtJyk7XG52YXIgVHJhbnNmb3JtID0gc3RyZWFtLlRyYW5zZm9ybTtcbnZhciB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IERhdGFTdHJlYW07XG5cbi8qKlxuICogRXNjYXBlcyBkb3RzIGluIHRoZSBiZWdpbm5pbmcgb2YgbGluZXMuIEVuZHMgdGhlIHN0cmVhbSB3aXRoIDxDUj48TEY+LjxDUj48TEY+XG4gKiBBbHNvIG1ha2VzIHN1cmUgdGhhdCBvbmx5IDxDUj48TEY+IHNlcXVlbmNlcyBhcmUgdXNlZCBmb3IgbGluZWJyZWFrc1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIFN0cmVhbSBvcHRpb25zXG4gKi9cbmZ1bmN0aW9uIERhdGFTdHJlYW0ob3B0aW9ucykge1xuICAgIC8vIGluaXQgVHJhbnNmb3JtXG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICB0aGlzLl9jdXJMaW5lID0gJyc7XG5cbiAgICB0aGlzLmluQnl0ZUNvdW50ID0gMDtcbiAgICB0aGlzLm91dEJ5dGVDb3VudCA9IDA7XG4gICAgdGhpcy5sYXN0Qnl0ZSA9IGZhbHNlO1xuXG4gICAgVHJhbnNmb3JtLmNhbGwodGhpcywgdGhpcy5vcHRpb25zKTtcbn1cbnV0aWwuaW5oZXJpdHMoRGF0YVN0cmVhbSwgVHJhbnNmb3JtKTtcblxuLyoqXG4gKiBFc2NhcGVzIGRvdHNcbiAqL1xuRGF0YVN0cmVhbS5wcm90b3R5cGUuX3RyYW5zZm9ybSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGRvbmUpIHtcbiAgICB2YXIgY2h1bmtzID0gW107XG4gICAgdmFyIGNodW5rbGVuID0gMDtcbiAgICB2YXIgaSwgbGVuLCBsYXN0UG9zID0gMDtcbiAgICB2YXIgYnVmO1xuXG4gICAgaWYgKCFjaHVuayB8fCAhY2h1bmsubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBkb25lKCk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBjaHVuayA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgY2h1bmsgPSBuZXcgQnVmZmVyKGNodW5rKTtcbiAgICB9XG5cbiAgICB0aGlzLmluQnl0ZUNvdW50ICs9IGNodW5rLmxlbmd0aDtcblxuICAgIGZvciAoaSA9IDAsIGxlbiA9IGNodW5rLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGlmIChjaHVua1tpXSA9PT0gMHgyRSkgeyAvLyAuXG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgKGkgJiYgY2h1bmtbaSAtIDFdID09PSAweDBBKSB8fFxuICAgICAgICAgICAgICAgICghaSAmJiAoIXRoaXMubGFzdEJ5dGUgfHwgdGhpcy5sYXN0Qnl0ZSA9PT0gMHgwQSkpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBidWYgPSBjaHVuay5zbGljZShsYXN0UG9zLCBpICsgMSk7XG4gICAgICAgICAgICAgICAgY2h1bmtzLnB1c2goYnVmKTtcbiAgICAgICAgICAgICAgICBjaHVua3MucHVzaChuZXcgQnVmZmVyKCcuJykpO1xuICAgICAgICAgICAgICAgIGNodW5rbGVuICs9IGJ1Zi5sZW5ndGggKyAxO1xuICAgICAgICAgICAgICAgIGxhc3RQb3MgPSBpICsgMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChjaHVua1tpXSA9PT0gMHgwQSkgeyAvLyAuXG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgKGkgJiYgY2h1bmtbaSAtIDFdICE9PSAweDBEKSB8fFxuICAgICAgICAgICAgICAgICghaSAmJiB0aGlzLmxhc3RCeXRlICE9PSAweDBEKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgaWYgKGkgPiBsYXN0UG9zKSB7XG4gICAgICAgICAgICAgICAgICAgIGJ1ZiA9IGNodW5rLnNsaWNlKGxhc3RQb3MsIGkpO1xuICAgICAgICAgICAgICAgICAgICBjaHVua3MucHVzaChidWYpO1xuICAgICAgICAgICAgICAgICAgICBjaHVua2xlbiArPSBidWYubGVuZ3RoICsgMjtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjaHVua2xlbiArPSAyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjaHVua3MucHVzaChuZXcgQnVmZmVyKCdcXHJcXG4nKSk7XG4gICAgICAgICAgICAgICAgbGFzdFBvcyA9IGkgKyAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNodW5rbGVuKSB7XG4gICAgICAgIC8vIGFkZCBsYXN0IHBpZWNlXG4gICAgICAgIGlmIChsYXN0UG9zIDwgY2h1bmsubGVuZ3RoKSB7XG4gICAgICAgICAgICBidWYgPSBjaHVuay5zbGljZShsYXN0UG9zKTtcbiAgICAgICAgICAgIGNodW5rcy5wdXNoKGJ1Zik7XG4gICAgICAgICAgICBjaHVua2xlbiArPSBidWYubGVuZ3RoO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5vdXRCeXRlQ291bnQgKz0gY2h1bmtsZW47XG4gICAgICAgIHRoaXMucHVzaChCdWZmZXIuY29uY2F0KGNodW5rcywgY2h1bmtsZW4pKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLm91dEJ5dGVDb3VudCArPSBjaHVuay5sZW5ndGg7XG4gICAgICAgIHRoaXMucHVzaChjaHVuayk7XG4gICAgfVxuXG4gICAgdGhpcy5sYXN0Qnl0ZSA9IGNodW5rW2NodW5rLmxlbmd0aCAtIDFdO1xuICAgIGRvbmUoKTtcbn07XG5cbi8qKlxuICogRmluYWxpemVzIHRoZSBzdHJlYW0gd2l0aCBhIGRvdCBvbiBhIHNpbmdsZSBsaW5lXG4gKi9cbkRhdGFTdHJlYW0ucHJvdG90eXBlLl9mbHVzaCA9IGZ1bmN0aW9uIChkb25lKSB7XG4gICAgdmFyIGJ1ZjtcbiAgICBpZiAodGhpcy5sYXN0Qnl0ZSA9PT0gMHgwQSkge1xuICAgICAgICBidWYgPSBuZXcgQnVmZmVyKCcuXFxyXFxuJyk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmxhc3RCeXRlID09PSAweDBEKSB7XG4gICAgICAgIGJ1ZiA9IG5ldyBCdWZmZXIoJ1xcbi5cXHJcXG4nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBidWYgPSBuZXcgQnVmZmVyKCdcXHJcXG4uXFxyXFxuJyk7XG4gICAgfVxuICAgIHRoaXMub3V0Qnl0ZUNvdW50ICs9IGJ1Zi5sZW5ndGg7XG4gICAgdGhpcy5wdXNoKGJ1Zik7XG4gICAgZG9uZSgpO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/smtp-connection/lib/data-stream.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/smtp-connection/lib/smtp-connection.js":
/*!*************************************************************!*\
  !*** ./node_modules/smtp-connection/lib/smtp-connection.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nvar packageInfo = __webpack_require__(/*! ../package.json */ \"(rsc)/./node_modules/smtp-connection/package.json\");\nvar EventEmitter = (__webpack_require__(/*! events */ \"events\").EventEmitter);\nvar util = __webpack_require__(/*! util */ \"util\");\nvar net = __webpack_require__(/*! net */ \"net\");\nvar tls = __webpack_require__(/*! tls */ \"tls\");\nvar os = __webpack_require__(/*! os */ \"os\");\nvar crypto = __webpack_require__(/*! crypto */ \"crypto\");\nvar DataStream = __webpack_require__(/*! ./data-stream */ \"(rsc)/./node_modules/smtp-connection/lib/data-stream.js\");\nvar PassThrough = (__webpack_require__(/*! stream */ \"stream\").PassThrough);\nvar shared = __webpack_require__(/*! nodemailer-shared */ \"(rsc)/./node_modules/nodemailer-shared/lib/shared.js\");\nvar ntlm = __webpack_require__(/*! httpntlm/ntlm */ \"(rsc)/./node_modules/httpntlm/ntlm.js\");\n\n// default timeout values in ms\nvar CONNECTION_TIMEOUT = 2 * 60 * 1000; // how much to wait for the connection to be established\nvar SOCKET_TIMEOUT = 10 * 60 * 1000; // how much to wait for socket inactivity before disconnecting the client\nvar GREETING_TIMEOUT = 30 * 1000; // how much to wait after connection is established but SMTP greeting is not receieved\n\nmodule.exports = SMTPConnection;\n\n/**\n * Generates a SMTP connection object\n *\n * Optional options object takes the following possible properties:\n *\n *  * **port** - is the port to connect to (defaults to 25 or 465)\n *  * **host** - is the hostname or IP address to connect to (defaults to 'localhost')\n *  * **secure** - use SSL\n *  * **ignoreTLS** - ignore server support for STARTTLS\n *  * **requireTLS** - forces the client to use STARTTLS\n *  * **name** - the name of the client server\n *  * **localAddress** - outbound address to bind to (see: http://nodejs.org/api/net.html#net_net_connect_options_connectionlistener)\n *  * **greetingTimeout** - Time to wait in ms until greeting message is received from the server (defaults to 10000)\n *  * **connectionTimeout** - how many milliseconds to wait for the connection to establish\n *  * **socketTimeout** - Time of inactivity until the connection is closed (defaults to 1 hour)\n *  * **lmtp** - if true, uses LMTP instead of SMTP protocol\n *  * **logger** - bunyan compatible logger interface\n *  * **debug** - if true pass SMTP traffic to the logger\n *  * **tls** - options for createCredentials\n *  * **socket** - existing socket to use instead of creating a new one (see: http://nodejs.org/api/net.html#net_class_net_socket)\n *  * **secured** - boolean indicates that the provided socket has already been upgraded to tls\n *\n * @constructor\n * @namespace SMTP Client module\n * @param {Object} [options] Option properties\n */\nfunction SMTPConnection(options) {\n    EventEmitter.call(this);\n\n    this.id = crypto.randomBytes(8).toString('base64').replace(/\\W/g, '');\n    this.stage = 'init';\n\n    this.options = options || {};\n\n    this.secureConnection = !!this.options.secure;\n    this.alreadySecured = !!this.options.secured;\n\n    this.port = this.options.port || (this.secureConnection ? 465 : 25);\n    this.host = this.options.host || 'localhost';\n\n    if (typeof this.options.secure === 'undefined' && this.port === 465) {\n        // if secure option is not set but port is 465, then default to secure\n        this.secureConnection = true;\n    }\n\n    this.name = this.options.name || this._getHostname();\n\n    this.logger = shared.getLogger(this.options);\n\n    /**\n     * Expose version nr, just for the reference\n     * @type {String}\n     */\n    this.version = packageInfo.version;\n\n    /**\n     * If true, then the user is authenticated\n     * @type {Boolean}\n     */\n    this.authenticated = false;\n\n    /**\n     * If set to true, this instance is no longer active\n     * @private\n     */\n    this.destroyed = false;\n\n    /**\n     * Defines if the current connection is secure or not. If not,\n     * STARTTLS can be used if available\n     * @private\n     */\n    this.secure = !!this.secureConnection;\n\n    /**\n     * Store incomplete messages coming from the server\n     * @private\n     */\n    this._remainder = '';\n\n    /**\n     * Unprocessed responses from the server\n     * @type {Array}\n     */\n    this._responseQueue = [];\n\n    /**\n     * The socket connecting to the server\n     * @publick\n     */\n    this._socket = false;\n\n    /**\n     * Lists supported auth mechanisms\n     * @private\n     */\n    this._supportedAuth = [];\n\n    /**\n     * Includes current envelope (from, to)\n     * @private\n     */\n    this._envelope = false;\n\n    /**\n     * Lists supported extensions\n     * @private\n     */\n    this._supportedExtensions = [];\n\n    /**\n     * Defines the maximum allowed size for a single message\n     * @private\n     */\n    this._maxAllowedSize = 0;\n\n    /**\n     * Function queue to run if a data chunk comes from the server\n     * @private\n     */\n    this._responseActions = [];\n    this._recipientQueue = [];\n\n    /**\n     * Timeout variable for waiting the greeting\n     * @private\n     */\n    this._greetingTimeout = false;\n\n    /**\n     * Timeout variable for waiting the connection to start\n     * @private\n     */\n    this._connectionTimeout = false;\n\n    /**\n     * If the socket is deemed already closed\n     * @private\n     */\n    this._destroyed = false;\n\n    /**\n     * If the socket is already being closed\n     * @private\n     */\n    this._closing = false;\n}\nutil.inherits(SMTPConnection, EventEmitter);\n\n/**\n * Creates a connection to a SMTP server and sets up connection\n * listener\n */\nSMTPConnection.prototype.connect = function (connectCallback) {\n    if (typeof connectCallback === 'function') {\n        this.once('connect', function () {\n            this.logger.debug('[%s] SMTP handshake finished', this.id);\n            connectCallback();\n        }.bind(this));\n    }\n\n    var opts = {\n        port: this.port,\n        host: this.host\n    };\n\n    if (this.options.localAddress) {\n        opts.localAddress = this.options.localAddress;\n    }\n\n    if (this.options.connection) {\n        // connection is already opened\n        this._socket = this.options.connection;\n        if (this.secureConnection && !this.alreadySecured) {\n            setImmediate(this._upgradeConnection.bind(this, function (err) {\n                if (err) {\n                    this._onError(new Error('Error initiating TLS - ' + (err.message || err)), 'ETLS', false, 'CONN');\n                    return;\n                }\n                this._onConnect();\n            }.bind(this)));\n        } else {\n            setImmediate(this._onConnect.bind(this));\n        }\n    } else if (this.options.socket) {\n        // socket object is set up but not yet connected\n        this._socket = this.options.socket;\n        try {\n            this._socket.connect(this.port, this.host, this._onConnect.bind(this));\n        } catch (E) {\n            return setImmediate(this._onError.bind(this, E, 'ECONNECTION', false, 'CONN'));\n        }\n    } else if (this.secureConnection) {\n        // connect using tls\n        if (this.options.tls) {\n            Object.keys(this.options.tls).forEach(function (key) {\n                opts[key] = this.options.tls[key];\n            }.bind(this));\n        }\n        try {\n            this._socket = tls.connect(this.port, this.host, opts, this._onConnect.bind(this));\n        } catch (E) {\n            return setImmediate(this._onError.bind(this, E, 'ECONNECTION', false, 'CONN'));\n        }\n    } else {\n        // connect using plaintext\n        try {\n            this._socket = net.connect(opts, this._onConnect.bind(this));\n        } catch (E) {\n            return setImmediate(this._onError.bind(this, E, 'ECONNECTION', false, 'CONN'));\n        }\n    }\n\n    this._connectionTimeout = setTimeout(function () {\n        this._onError('Connection timeout', 'ETIMEDOUT', false, 'CONN');\n    }.bind(this), this.options.connectionTimeout || CONNECTION_TIMEOUT);\n\n    this._socket.on('error', function (err) {\n        this._onError(err, 'ECONNECTION', false, 'CONN');\n    }.bind(this));\n};\n\n/**\n * Sends QUIT\n */\nSMTPConnection.prototype.quit = function () {\n    this._sendCommand('QUIT');\n    this._responseActions.push(this.close);\n};\n\n/**\n * Closes the connection to the server\n */\nSMTPConnection.prototype.close = function () {\n    clearTimeout(this._connectionTimeout);\n    clearTimeout(this._greetingTimeout);\n    this._responseActions = [];\n\n    // allow to run this function only once\n    if (this._closing) {\n        return;\n    }\n    this._closing = true;\n\n    var closeMethod = 'end';\n\n    if (this.stage === 'init') {\n        // Close the socket immediately when connection timed out\n        closeMethod = 'destroy';\n    }\n\n    this.logger.debug('[%s] Closing connection to the server using \"%s\"', this.id, closeMethod);\n\n    var socket = this._socket && this._socket.socket || this._socket;\n\n    if (socket && !socket.destroyed) {\n        try {\n            this._socket[closeMethod]();\n        } catch (E) {\n            // just ignore\n        }\n    }\n\n    this._destroy();\n};\n\n/**\n * Authenticate user\n */\nSMTPConnection.prototype.login = function (authData, callback) {\n    this._auth = authData || {};\n    this._user = this._auth.xoauth2 && this._auth.xoauth2.options && this._auth.xoauth2.options.user || this._auth.user || '';\n\n    this._authMethod = false;\n    if (this.options.authMethod) {\n        this._authMethod = this.options.authMethod.toUpperCase().trim();\n    } else if (this._auth.xoauth2 && this._supportedAuth.indexOf('XOAUTH2') >= 0) {\n        this._authMethod = 'XOAUTH2';\n    } else if (this._auth.domain && this._supportedAuth.indexOf('NTLM') >= 0) {\n        this._authMethod = 'NTLM';\n    } else {\n        // use first supported\n        this._authMethod = (this._supportedAuth[0] || 'PLAIN').toUpperCase().trim();\n    }\n\n    switch (this._authMethod) {\n        case 'XOAUTH2':\n            this._handleXOauth2Token(false, callback);\n            return;\n        case 'LOGIN':\n            this._responseActions.push(function (str) {\n                this._actionAUTH_LOGIN_USER(str, callback);\n            }.bind(this));\n            this._sendCommand('AUTH LOGIN');\n            return;\n        case 'PLAIN':\n            this._responseActions.push(function (str) {\n                this._actionAUTHComplete(str, callback);\n            }.bind(this));\n            this._sendCommand('AUTH PLAIN ' + new Buffer(\n                //this._auth.user+'\\u0000'+\n                '\\u0000' + // skip authorization identity as it causes problems with some servers\n                this._auth.user + '\\u0000' +\n                this._auth.pass, 'utf-8').toString('base64'));\n            return;\n        case 'CRAM-MD5':\n            this._responseActions.push(function (str) {\n                this._actionAUTH_CRAM_MD5(str, callback);\n            }.bind(this));\n            this._sendCommand('AUTH CRAM-MD5');\n            return;\n        case 'NTLM':\n            this._responseActions.push(function (str) {\n                this._actionAUTH_NTLM_TYPE1(str, callback);\n            }.bind(this));\n            this._sendCommand('AUTH ' + ntlm.createType1Message({\n                domain: this._auth.domain || '',\n                workstation: this._auth.workstation || ''\n            }));\n            return;\n    }\n\n    return callback(this._formatError('Unknown authentication method \"' + this._authMethod + '\"', 'EAUTH', false, 'API'));\n};\n\n/**\n * Sends a message\n *\n * @param {Object} envelope Envelope object, {from: addr, to: [addr]}\n * @param {Object} message String, Buffer or a Stream\n * @param {Function} callback Callback to return once sending is completed\n */\nSMTPConnection.prototype.send = function (envelope, message, done) {\n    if (!message) {\n        return done(this._formatError('Empty message', 'EMESSAGE', false, 'API'));\n    }\n\n    // reject larger messages than allowed\n    if (this._maxAllowedSize && envelope.size > this._maxAllowedSize) {\n        return setImmediate(function () {\n            done(this._formatError('Message size larger than allowed ' + this._maxAllowedSize, 'EMESSAGE', false, 'MAIL FROM'));\n        }.bind(this));\n    }\n\n    // ensure that callback is only called once\n    var returned = false;\n    var callback = function () {\n        if (returned) {\n            return;\n        }\n        returned = true;\n\n        done.apply(null, Array.prototype.slice.call(arguments));\n    };\n\n    if (typeof message.on === 'function') {\n        message.on('error', function (err) {\n            return callback(this._formatError(err, 'ESTREAM', false, 'API'));\n        }.bind(this));\n    }\n\n    this._setEnvelope(envelope, function (err, info) {\n        if (err) {\n            return callback(err);\n        }\n        var stream = this._createSendStream(function (err, str) {\n            if (err) {\n                return callback(err);\n            }\n            info.response = str;\n            return callback(null, info);\n        });\n        if (typeof message.pipe === 'function') {\n            message.pipe(stream);\n        } else {\n            stream.write(message);\n            stream.end();\n        }\n\n    }.bind(this));\n};\n\n/**\n * Resets connection state\n *\n * @param {Function} callback Callback to return once connection is reset\n */\nSMTPConnection.prototype.reset = function (callback) {\n    this._sendCommand('RSET');\n    this._responseActions.push(function (str) {\n        if (str.charAt(0) !== '2') {\n            return callback(this._formatError('Could not reset session state:\\n' + str, 'EPROTOCOL', str, 'RSET'));\n        }\n        this._envelope = false;\n        return callback(null, true);\n    }.bind(this));\n};\n\n/**\n * Connection listener that is run when the connection to\n * the server is opened\n *\n * @event\n */\nSMTPConnection.prototype._onConnect = function () {\n    clearTimeout(this._connectionTimeout);\n\n    this.logger.info('[%s] %s established to %s:%s', this.id, this.secure ? 'Secure connection' : 'Connection', this._socket.remoteAddress, this._socket.remotePort);\n\n    if (this._destroyed) {\n        // Connection was established after we already had canceled it\n        this.close();\n        return;\n    }\n\n    this.stage = 'connected';\n\n    // clear existing listeners for the socket\n    this._socket.removeAllListeners('data');\n    this._socket.removeAllListeners('timeout');\n    this._socket.removeAllListeners('close');\n    this._socket.removeAllListeners('end');\n\n    this._socket.on('data', this._onData.bind(this));\n    this._socket.once('close', this._onClose.bind(this));\n    this._socket.once('end', this._onEnd.bind(this));\n\n    this._socket.setTimeout(this.options.socketTimeout || SOCKET_TIMEOUT);\n    this._socket.on('timeout', this._onTimeout.bind(this));\n\n    this._greetingTimeout = setTimeout(function () {\n        // if still waiting for greeting, give up\n        if (this._socket && !this._destroyed && this._responseActions[0] === this._actionGreeting) {\n            this._onError('Greeting never received', 'ETIMEDOUT', false, 'CONN');\n        }\n    }.bind(this), this.options.greetingTimeout || GREETING_TIMEOUT);\n\n    this._responseActions.push(this._actionGreeting);\n\n    // we have a 'data' listener set up so resume socket if it was paused\n    this._socket.resume();\n};\n\n/**\n * 'data' listener for data coming from the server\n *\n * @event\n * @param {Buffer} chunk Data chunk coming from the server\n */\nSMTPConnection.prototype._onData = function (chunk) {\n    if (this._destroyed || !chunk || !chunk.length) {\n        return;\n    }\n\n    var data = (chunk || '').toString('binary');\n    var lines = (this._remainder + data).split(/\\r?\\n/);\n    var lastline;\n\n    this._remainder = lines.pop();\n\n    for (var i = 0, len = lines.length; i < len; i++) {\n        if (this._responseQueue.length) {\n            lastline = this._responseQueue[this._responseQueue.length - 1];\n            if (/^\\d+\\-/.test(lastline.split('\\n').pop())) {\n                this._responseQueue[this._responseQueue.length - 1] += '\\n' + lines[i];\n                continue;\n            }\n        }\n        this._responseQueue.push(lines[i]);\n    }\n\n    this._processResponse();\n};\n\n/**\n * 'error' listener for the socket\n *\n * @event\n * @param {Error} err Error object\n * @param {String} type Error name\n */\nSMTPConnection.prototype._onError = function (err, type, data, command) {\n    clearTimeout(this._connectionTimeout);\n    clearTimeout(this._greetingTimeout);\n\n    if (this._destroyed) {\n        // just ignore, already closed\n        // this might happen when a socket is canceled because of reached timeout\n        // but the socket timeout error itself receives only after\n        return;\n    }\n\n    err = this._formatError(err, type, data, command);\n\n    this.logger.error('[%s] %s', this.id, err.message);\n\n    this.emit('error', err);\n    this.close();\n};\n\nSMTPConnection.prototype._formatError = function (message, type, response, command) {\n    var err;\n\n    if (/Error\\]$/i.test(Object.prototype.toString.call(message))) {\n        err = message;\n    } else {\n        err = new Error(message);\n    }\n\n    if (type && type !== 'Error') {\n        err.code = type;\n    }\n\n    if (response) {\n        err.response = response;\n        err.message += ': ' + response;\n    }\n\n    var responseCode = typeof response === 'string' && Number((response.match(/^\\d+/) || [])[0]) || false;\n    if (responseCode) {\n        err.responseCode = responseCode;\n    }\n\n    if (command) {\n        err.command = command;\n    }\n\n    return err;\n};\n\n/**\n * 'close' listener for the socket\n *\n * @event\n */\nSMTPConnection.prototype._onClose = function () {\n    this.logger.info('[%s] Connection closed', this.id);\n\n    if ([this._actionGreeting, this.close].indexOf(this._responseActions[0]) < 0 && !this._destroyed) {\n        return this._onError(new Error('Connection closed unexpectedly'), 'ECONNECTION', false, 'CONN');\n    }\n\n    this._destroy();\n};\n\n/**\n * 'end' listener for the socket\n *\n * @event\n */\nSMTPConnection.prototype._onEnd = function () {\n    this._destroy();\n};\n\n/**\n * 'timeout' listener for the socket\n *\n * @event\n */\nSMTPConnection.prototype._onTimeout = function () {\n    return this._onError(new Error('Timeout'), 'ETIMEDOUT', false, 'CONN');\n};\n\n/**\n * Destroys the client, emits 'end'\n */\nSMTPConnection.prototype._destroy = function () {\n    if (this._destroyed) {\n        return;\n    }\n    this._destroyed = true;\n    this.emit('end');\n};\n\n/**\n * Upgrades the connection to TLS\n *\n * @param {Function} callback Callback function to run when the connection\n *        has been secured\n */\nSMTPConnection.prototype._upgradeConnection = function (callback) {\n    // do not remove all listeners or it breaks node v0.10 as there's\n    // apparently a 'finish' event set that would be cleared as well\n\n    // we can safely keep 'error', 'end', 'close' etc. events\n    this._socket.removeAllListeners('data'); // incoming data is going to be gibberish from this point onwards\n    this._socket.removeAllListeners('timeout'); // timeout will be re-set for the new socket object\n\n    var socketPlain = this._socket;\n    var opts = {\n        socket: this._socket,\n        host: this.host\n    };\n\n    Object.keys(this.options.tls || {}).forEach(function (key) {\n        opts[key] = this.options.tls[key];\n    }.bind(this));\n\n    this._socket = tls.connect(opts, function () {\n        this.secure = true;\n        this._socket.on('data', this._onData.bind(this));\n\n        socketPlain.removeAllListeners('close');\n        socketPlain.removeAllListeners('end');\n\n        return callback(null, true);\n    }.bind(this));\n\n    this._socket.on('error', this._onError.bind(this));\n    this._socket.once('close', this._onClose.bind(this));\n    this._socket.once('end', this._onEnd.bind(this));\n\n    this._socket.setTimeout(this.options.socketTimeout || SOCKET_TIMEOUT); // 10 min.\n    this._socket.on('timeout', this._onTimeout.bind(this));\n\n    // resume in case the socket was paused\n    socketPlain.resume();\n};\n\n/**\n * Processes queued responses from the server\n *\n * @param {Boolean} force If true, ignores _processing flag\n */\nSMTPConnection.prototype._processResponse = function () {\n    if (!this._responseQueue.length) {\n        return false;\n    }\n\n    var str = (this._responseQueue.shift() || '').toString();\n\n    if (/^\\d+\\-/.test(str.split('\\n').pop())) {\n        // keep waiting for the final part of multiline response\n        return;\n    }\n\n    if (this.options.debug) {\n        this.logger.debug('[%s] S: %s', this.id, str.replace(/\\r?\\n$/, ''));\n    }\n\n    if (!str.trim()) { // skip unexpected empty lines\n        setImmediate(this._processResponse.bind(this, true));\n    }\n\n    var action = this._responseActions.shift();\n\n    if (typeof action === 'function') {\n        action.call(this, str);\n        setImmediate(this._processResponse.bind(this, true));\n    } else {\n        return this._onError(new Error('Unexpected Response'), 'EPROTOCOL', str, 'CONN');\n    }\n};\n\n/**\n * Send a command to the server, append \\r\\n\n *\n * @param {String} str String to be sent to the server\n */\nSMTPConnection.prototype._sendCommand = function (str) {\n    if (this._destroyed) {\n        // Connection already closed, can't send any more data\n        return;\n    }\n\n    if (this._socket.destroyed) {\n        return this.close();\n    }\n\n    if (this.options.debug) {\n        this.logger.debug('[%s] C: %s', this.id, (str || '').toString().replace(/\\r?\\n$/, ''));\n    }\n\n    this._socket.write(new Buffer(str + '\\r\\n', 'utf-8'));\n};\n\n/**\n * Initiates a new message by submitting envelope data, starting with\n * MAIL FROM: command\n *\n * @param {Object} envelope Envelope object in the form of\n *        {from:'...', to:['...']}\n *        or\n *        {from:{address:'...',name:'...'}, to:[address:'...',name:'...']}\n */\nSMTPConnection.prototype._setEnvelope = function (envelope, callback) {\n    var args = [];\n    var useSmtpUtf8 = false;\n\n    this._envelope = envelope || {};\n    this._envelope.from = (this._envelope.from && this._envelope.from.address || this._envelope.from || '').toString().trim();\n\n    this._envelope.to = [].concat(this._envelope.to || []).map(function (to) {\n        return (to && to.address || to || '').toString().trim();\n    });\n\n    if (!this._envelope.to.length) {\n        return callback(this._formatError('No recipients defined', 'EENVELOPE', false, 'API'));\n    }\n\n    if (this._envelope.from && /[\\r\\n<>]/.test(this._envelope.from)) {\n        return callback(this._formatError('Invalid sender ' + JSON.stringify(this._envelope.from), 'EENVELOPE', false, 'API'));\n    }\n\n    // check if the sender address uses only ASCII characters,\n    // otherwise require usage of SMTPUTF8 extension\n    if (/[\\x80-\\uFFFF]/.test(this._envelope.from)) {\n        useSmtpUtf8 = true;\n    }\n\n    for (var i = 0, len = this._envelope.to.length; i < len; i++) {\n        if (!this._envelope.to[i] || /[\\r\\n<>]/.test(this._envelope.to[i])) {\n            return callback(this._formatError('Invalid recipient ' + JSON.stringify(this._envelope.to[i]), 'EENVELOPE', false, 'API'));\n        }\n\n        // check if the recipients addresses use only ASCII characters,\n        // otherwise require usage of SMTPUTF8 extension\n        if (/[\\x80-\\uFFFF]/.test(this._envelope.to[i])) {\n            useSmtpUtf8 = true;\n        }\n    }\n\n    // clone the recipients array for latter manipulation\n    this._envelope.rcptQueue = JSON.parse(JSON.stringify(this._envelope.to || []));\n    this._envelope.rejected = [];\n    this._envelope.rejectedErrors = [];\n    this._envelope.accepted = [];\n\n    if (this._envelope.dsn) {\n        try {\n            this._envelope.dsn = this._setDsnEnvelope(this._envelope.dsn);\n        } catch (err) {\n            return callback(this._formatError('Invalid dsn ' + err.message, 'EENVELOPE', false, 'API'));\n        }\n    }\n\n    this._responseActions.push(function (str) {\n        this._actionMAIL(str, callback);\n    }.bind(this));\n\n    // If the server supports SMTPUTF8 and the envelope includes an internationalized\n    // email address then append SMTPUTF8 keyword to the MAIL FROM command\n    if (useSmtpUtf8 && this._supportedExtensions.indexOf('SMTPUTF8') >= 0) {\n        args.push('SMTPUTF8');\n        this._usingSmtpUtf8 = true;\n    }\n\n    // If the server supports 8BITMIME and the message might contain non-ascii bytes\n    // then append the 8BITMIME keyword to the MAIL FROM command\n    if (this._envelope.use8BitMime && this._supportedExtensions.indexOf('8BITMIME') >= 0) {\n        args.push('BODY=8BITMIME');\n        this._using8BitMime = true;\n    }\n\n    if (this._envelope.size && this._supportedExtensions.indexOf('SIZE') >= 0) {\n        args.push('SIZE=' + this._envelope.size);\n    }\n\n    // If the server supports DSN and the envelope includes an DSN prop\n    // then append DSN params to the MAIL FROM command\n    if (this._envelope.dsn && this._supportedExtensions.indexOf('DSN') >= 0) {\n        if (this._envelope.dsn.ret) {\n            args.push('RET=' + this._envelope.dsn.ret);\n        }\n        if (this._envelope.dsn.envid) {\n            args.push('ENVID=' + this._envelope.dsn.envid);\n        }\n    }\n\n    this._sendCommand('MAIL FROM:<' + (this._envelope.from) + '>' + (args.length ? ' ' + args.join(' ') : ''));\n};\n\nSMTPConnection.prototype._setDsnEnvelope = function (params) {\n    var ret = params.ret ? params.ret.toString().toUpperCase() : null;\n    if (ret && ['FULL', 'HDRS'].indexOf(ret) < 0) {\n        throw new Error('ret: ' + JSON.stringify(ret));\n    }\n    var envid = params.envid ? params.envid.toString() : null;\n    var notify = params.notify ? params.notify : null;\n    if (notify) {\n        if (typeof notify === 'string') {\n            notify = notify.split(',');\n        }\n        notify = notify.map(function (n) {\n            return n.trim().toUpperCase();\n        });\n        var validNotify = ['NEVER', 'SUCCESS', 'FAILURE', 'DELAY'];\n        var invaliNotify = notify.filter(function (n) {\n            return validNotify.indexOf(n) === -1;\n        });\n        if (invaliNotify.length || (notify.length > 1 && notify.indexOf('NEVER') >= 0)) {\n            throw new Error('notify: ' + JSON.stringify(notify.join(',')));\n        }\n        notify = notify.join(',');\n    }\n    var orcpt = params.orcpt ? params.orcpt.toString() : null;\n    return {\n        ret: ret,\n        envid: envid,\n        notify: notify,\n        orcpt: orcpt\n    };\n};\n\nSMTPConnection.prototype._getDsnRcptToArgs = function () {\n    var args = [];\n    // If the server supports DSN and the envelope includes an DSN prop\n    // then append DSN params to the RCPT TO command\n    if (this._envelope.dsn && this._supportedExtensions.indexOf('DSN') >= 0) {\n        if (this._envelope.dsn.notify) {\n            args.push('NOTIFY=' + this._envelope.dsn.notify);\n        }\n        if (this._envelope.dsn.orcpt) {\n            args.push('ORCPT=' + this._envelope.dsn.orcpt);\n        }\n    }\n    return (args.length ? ' ' + args.join(' ') : '');\n};\n\nSMTPConnection.prototype._createSendStream = function (callback) {\n    var dataStream = new DataStream();\n    var logStream;\n\n    if (this.options.lmtp) {\n        this._envelope.accepted.forEach(function (recipient, i) {\n            var final = i === this._envelope.accepted.length - 1;\n            this._responseActions.push(function (str) {\n                this._actionLMTPStream(recipient, final, str, callback);\n            }.bind(this));\n        }.bind(this));\n    } else {\n        this._responseActions.push(function (str) {\n            this._actionSMTPStream(str, callback);\n        }.bind(this));\n    }\n\n    dataStream.pipe(this._socket, {\n        end: false\n    });\n\n    if (this.options.debug) {\n        logStream = new PassThrough();\n        logStream.on('readable', function () {\n            var chunk;\n            while ((chunk = logStream.read())) {\n                this.logger.debug('[%s] C: %s', this.id, chunk.toString('binary').replace(/\\r?\\n$/, ''));\n            }\n        }.bind(this));\n        dataStream.pipe(logStream);\n    }\n\n    dataStream.once('end', function () {\n        this.logger.info('[%s] C: <%s bytes encoded mime message (source size %s bytes)>', this.id, dataStream.outByteCount, dataStream.inByteCount);\n    }.bind(this));\n\n    return dataStream;\n};\n\n/** ACTIONS **/\n\n/**\n * Will be run after the connection is created and the server sends\n * a greeting. If the incoming message starts with 220 initiate\n * SMTP session by sending EHLO command\n *\n * @param {String} str Message from the server\n */\nSMTPConnection.prototype._actionGreeting = function (str) {\n    clearTimeout(this._greetingTimeout);\n\n    if (str.substr(0, 3) !== '220') {\n        this._onError(new Error('Invalid greeting from server:\\n' + str), 'EPROTOCOL', str, 'CONN');\n        return;\n    }\n\n    if (this.options.lmtp) {\n        this._responseActions.push(this._actionLHLO);\n        this._sendCommand('LHLO ' + this.name);\n    } else {\n        this._responseActions.push(this._actionEHLO);\n        this._sendCommand('EHLO ' + this.name);\n    }\n};\n\n/**\n * Handles server response for LHLO command. If it yielded in\n * error, emit 'error', otherwise treat this as an EHLO response\n *\n * @param {String} str Message from the server\n */\nSMTPConnection.prototype._actionLHLO = function (str) {\n    if (str.charAt(0) !== '2') {\n        this._onError(new Error('Invalid response for LHLO:\\n' + str), 'EPROTOCOL', str, 'LHLO');\n        return;\n    }\n\n    this._actionEHLO(str);\n};\n\n/**\n * Handles server response for EHLO command. If it yielded in\n * error, try HELO instead, otherwise initiate TLS negotiation\n * if STARTTLS is supported by the server or move into the\n * authentication phase.\n *\n * @param {String} str Message from the server\n */\nSMTPConnection.prototype._actionEHLO = function (str) {\n    var match;\n\n    if (str.substr(0, 3) === '421') {\n        this._onError(new Error('Server terminates connection:\\n' + str), 'ECONNECTION', str, 'EHLO');\n        return;\n    }\n\n    if (str.charAt(0) !== '2') {\n        if (this.options.requireTLS) {\n            this._onError(new Error('EHLO failed but HELO does not support required STARTTLS:\\n' + str), 'ECONNECTION', str, 'EHLO');\n            return;\n        }\n\n        // Try HELO instead\n        this._responseActions.push(this._actionHELO);\n        this._sendCommand('HELO ' + this.name);\n        return;\n    }\n\n    // Detect if the server supports STARTTLS\n    if (!this.secure && !this.options.ignoreTLS && (/[ \\-]STARTTLS\\b/mi.test(str) || this.options.requireTLS)) {\n        this._sendCommand('STARTTLS');\n        this._responseActions.push(this._actionSTARTTLS);\n        return;\n    }\n\n    // Detect if the server supports SMTPUTF8\n    if (/[ \\-]SMTPUTF8\\b/mi.test(str)) {\n        this._supportedExtensions.push('SMTPUTF8');\n    }\n\n    // Detect if the server supports DSN\n    if (/[ \\-]DSN\\b/mi.test(str)) {\n        this._supportedExtensions.push('DSN');\n    }\n\n    // Detect if the server supports 8BITMIME\n    if (/[ \\-]8BITMIME\\b/mi.test(str)) {\n        this._supportedExtensions.push('8BITMIME');\n    }\n\n    // Detect if the server supports PIPELINING\n    if (/[ \\-]PIPELINING\\b/mi.test(str)) {\n        this._supportedExtensions.push('PIPELINING');\n    }\n\n    // Detect if the server supports PLAIN auth\n    if (/AUTH(?:(\\s+|=)[^\\n]*\\s+|\\s+|=)PLAIN/i.test(str)) {\n        this._supportedAuth.push('PLAIN');\n    }\n\n    // Detect if the server supports LOGIN auth\n    if (/AUTH(?:(\\s+|=)[^\\n]*\\s+|\\s+|=)LOGIN/i.test(str)) {\n        this._supportedAuth.push('LOGIN');\n    }\n\n    // Detect if the server supports CRAM-MD5 auth\n    if (/AUTH(?:(\\s+|=)[^\\n]*\\s+|\\s+|=)CRAM-MD5/i.test(str)) {\n        this._supportedAuth.push('CRAM-MD5');\n    }\n\n    // Detect if the server supports XOAUTH2 auth\n    if (/AUTH(?:(\\s+|=)[^\\n]*\\s+|\\s+|=)XOAUTH2/i.test(str)) {\n        this._supportedAuth.push('XOAUTH2');\n    }\n\n    // Detect if the server supports SIZE extensions (and the max allowed size)\n    if ((match = str.match(/[ \\-]SIZE(?:\\s+(\\d+))?/mi))) {\n        this._supportedExtensions.push('SIZE');\n        this._maxAllowedSize = Number(match[1]) || 0;\n    }\n\n    this.emit('connect');\n};\n\n/**\n * Handles server response for HELO command. If it yielded in\n * error, emit 'error', otherwise move into the authentication phase.\n *\n * @param {String} str Message from the server\n */\nSMTPConnection.prototype._actionHELO = function (str) {\n    if (str.charAt(0) !== '2') {\n        this._onError(new Error('Invalid response for EHLO/HELO:\\n' + str), 'EPROTOCOL', str, 'HELO');\n        return;\n    }\n\n    this.emit('connect');\n};\n\n/**\n * Handles server response for STARTTLS command. If there's an error\n * try HELO instead, otherwise initiate TLS upgrade. If the upgrade\n * succeedes restart the EHLO\n *\n * @param {String} str Message from the server\n */\nSMTPConnection.prototype._actionSTARTTLS = function (str) {\n    if (str.charAt(0) !== '2') {\n        if (this.options.opportunisticTLS) {\n            this.logger.info('[%s] Failed STARTTLS upgrade, continuing unencrypted', this.id);\n            return this.emit('connect');\n        }\n        this._onError(new Error('Error upgrading connection with STARTTLS'), 'ETLS', str, 'STARTTLS');\n        return;\n    }\n\n    this._upgradeConnection(function (err, secured) {\n        if (err) {\n            this._onError(new Error('Error initiating TLS - ' + (err.message || err)), 'ETLS', false, 'STARTTLS');\n            return;\n        }\n\n        this.logger.info('[%s] Connection upgraded with STARTTLS', this.id);\n\n        if (secured) {\n            // restart session\n            this._responseActions.push(this._actionEHLO);\n            this._sendCommand('EHLO ' + this.name);\n        } else {\n            this.emit('connect');\n        }\n    }.bind(this));\n};\n\n/**\n * Handle the response for AUTH LOGIN command. We are expecting\n * '334 VXNlcm5hbWU6' (base64 for 'Username:'). Data to be sent as\n * response needs to be base64 encoded username.\n *\n * @param {String} str Message from the server\n */\nSMTPConnection.prototype._actionAUTH_LOGIN_USER = function (str, callback) {\n    if (str !== '334 VXNlcm5hbWU6') {\n        callback(this._formatError('Invalid login sequence while waiting for \"334 VXNlcm5hbWU6\"', 'EAUTH', str, 'AUTH LOGIN'));\n        return;\n    }\n\n    this._responseActions.push(function (str) {\n        this._actionAUTH_LOGIN_PASS(str, callback);\n    }.bind(this));\n\n    this._sendCommand(new Buffer(this._auth.user + '', 'utf-8').toString('base64'));\n};\n\n/**\n * Handle the response for AUTH NTLM, which should be a\n * '334 <challenge string>'. See http://davenport.sourceforge.net/ntlm.html\n * We already sent the Type1 message, the challenge is a Type2 message, we\n * need to respond with a Type3 message.\n *\n * @param {String} str Message from the server\n */\nSMTPConnection.prototype._actionAUTH_NTLM_TYPE1 = function (str, callback) {\n    var challengeMatch = str.match(/^334\\s+(.+)$/);\n    var challengeString = '';\n\n    if (!challengeMatch) {\n        return callback(this._formatError('Invalid login sequence while waiting for server challenge string', 'EAUTH', str, 'AUTH NTLM'));\n    } else {\n        challengeString = challengeMatch[1];\n    }\n\n    if (!/^NTLM/i.test(challengeString)) {\n        challengeString = 'NTLM ' + challengeString;\n    }\n\n    var type2Message = ntlm.parseType2Message(challengeString, callback);\n    if (!type2Message) {\n        return;\n    }\n\n    var type3Message = ntlm.createType3Message(type2Message, {\n        domain: this._auth.domain || '',\n        workstation: this._auth.workstation || '',\n        username: this._auth.user,\n        password: this._auth.pass\n    });\n\n    type3Message = type3Message.substring(5); // remove the \"NTLM \" prefix\n\n    this._responseActions.push(function (str) {\n        this._actionAUTH_NTLM_TYPE3(str, callback);\n    }.bind(this));\n\n    this._sendCommand(type3Message);\n};\n\n/**\n * Handle the response for AUTH CRAM-MD5 command. We are expecting\n * '334 <challenge string>'. Data to be sent as response needs to be\n * base64 decoded challenge string, MD5 hashed using the password as\n * a HMAC key, prefixed by the username and a space, and finally all\n * base64 encoded again.\n *\n * @param {String} str Message from the server\n */\nSMTPConnection.prototype._actionAUTH_CRAM_MD5 = function (str, callback) {\n    var challengeMatch = str.match(/^334\\s+(.+)$/);\n    var challengeString = '';\n\n    if (!challengeMatch) {\n        return callback(this._formatError('Invalid login sequence while waiting for server challenge string', 'EAUTH', str, 'AUTH CRAM-MD5'));\n    } else {\n        challengeString = challengeMatch[1];\n    }\n\n    // Decode from base64\n    var base64decoded = new Buffer(challengeString, 'base64').toString('ascii'),\n        hmac_md5 = crypto.createHmac('md5', this._auth.pass);\n\n    hmac_md5.update(base64decoded);\n\n    var hex_hmac = hmac_md5.digest('hex'),\n        prepended = this._auth.user + ' ' + hex_hmac;\n\n    this._responseActions.push(function (str) {\n        this._actionAUTH_CRAM_MD5_PASS(str, callback);\n    }.bind(this));\n\n\n    this._sendCommand(new Buffer(prepended).toString('base64'));\n};\n\n/**\n * Handles the response to CRAM-MD5 authentication, if there's no error,\n * the user can be considered logged in. Start waiting for a message to send\n *\n * @param {String} str Message from the server\n */\nSMTPConnection.prototype._actionAUTH_CRAM_MD5_PASS = function (str, callback) {\n    if (!str.match(/^235\\s+/)) {\n        return callback(this._formatError('Invalid login sequence while waiting for \"235\"', 'EAUTH', str, 'AUTH CRAM-MD5'));\n    }\n\n    this.logger.info('[%s] User %s authenticated', this.id, JSON.stringify(this._user));\n    this.authenticated = true;\n    callback(null, true);\n};\n\n/**\n * Handles the TYPE3 response for NTLM authentication, if there's no error,\n * the user can be considered logged in. Start waiting for a message to send\n *\n * @param {String} str Message from the server\n */\nSMTPConnection.prototype._actionAUTH_NTLM_TYPE3 = function (str, callback) {\n    if (!str.match(/^235\\s+/)) {\n        return callback(this._formatError('Invalid login sequence while waiting for \"235\"', 'EAUTH', str, 'AUTH NTLM'));\n    }\n\n    this.logger.info('[%s] User %s authenticated', this.id, JSON.stringify(this._user));\n    this.authenticated = true;\n    callback(null, true);\n};\n\n/**\n * Handle the response for AUTH LOGIN command. We are expecting\n * '334 UGFzc3dvcmQ6' (base64 for 'Password:'). Data to be sent as\n * response needs to be base64 encoded password.\n *\n * @param {String} str Message from the server\n */\nSMTPConnection.prototype._actionAUTH_LOGIN_PASS = function (str, callback) {\n    if (str !== '334 UGFzc3dvcmQ6') {\n        return callback(this._formatError('Invalid login sequence while waiting for \"334 UGFzc3dvcmQ6\"', 'EAUTH', str, 'AUTH LOGIN'));\n    }\n\n    this._responseActions.push(function (str) {\n        this._actionAUTHComplete(str, callback);\n    }.bind(this));\n\n    this._sendCommand(new Buffer(this._auth.pass + '', 'utf-8').toString('base64'));\n};\n\n/**\n * Handles the response for authentication, if there's no error,\n * the user can be considered logged in. Start waiting for a message to send\n *\n * @param {String} str Message from the server\n */\nSMTPConnection.prototype._actionAUTHComplete = function (str, isRetry, callback) {\n    if (!callback && typeof isRetry === 'function') {\n        callback = isRetry;\n        isRetry = undefined;\n    }\n\n    if (str.substr(0, 3) === '334') {\n        this._responseActions.push(function (str) {\n            if (isRetry || !this._auth.xoauth2 || typeof this._auth.xoauth2 !== 'object') {\n                this._actionAUTHComplete(str, true, callback);\n            } else {\n                setTimeout(this._handleXOauth2Token.bind(this, true, callback), Math.random() * 4000 + 1000);\n            }\n        }.bind(this));\n        this._sendCommand('');\n        return;\n    }\n\n    if (str.charAt(0) !== '2') {\n        this.logger.info('[%s] User %s failed to authenticate', this.id, JSON.stringify(this._user));\n        return callback(this._formatError('Invalid login', 'EAUTH', str, 'AUTH ' + this._authMethod));\n    }\n\n    this.logger.info('[%s] User %s authenticated', this.id, JSON.stringify(this._user));\n    this.authenticated = true;\n    callback(null, true);\n};\n\n/**\n * Handle response for a MAIL FROM: command\n *\n * @param {String} str Message from the server\n */\nSMTPConnection.prototype._actionMAIL = function (str, callback) {\n    var message, curRecipient;\n    if (Number(str.charAt(0)) !== 2) {\n        if (this._usingSmtpUtf8 && /^550 /.test(str) && /[\\x80-\\uFFFF]/.test(this._envelope.from)) {\n            message = 'Internationalized mailbox name not allowed';\n        } else {\n            message = 'Mail command failed';\n        }\n        return callback(this._formatError(message, 'EENVELOPE', str, 'MAIL FROM'));\n    }\n\n    if (!this._envelope.rcptQueue.length) {\n        return callback(this._formatError('Can\\'t send mail - no recipients defined', 'EENVELOPE', false, 'API'));\n    } else {\n        this._recipientQueue = [];\n\n        if (this._supportedExtensions.indexOf('PIPELINING') >= 0) {\n            while (this._envelope.rcptQueue.length) {\n                curRecipient = this._envelope.rcptQueue.shift();\n                this._recipientQueue.push(curRecipient);\n                this._responseActions.push(function (str) {\n                    this._actionRCPT(str, callback);\n                }.bind(this));\n                this._sendCommand('RCPT TO:<' + curRecipient + '>' + this._getDsnRcptToArgs());\n            }\n        } else {\n            curRecipient = this._envelope.rcptQueue.shift();\n            this._recipientQueue.push(curRecipient);\n            this._responseActions.push(function (str) {\n                this._actionRCPT(str, callback);\n            }.bind(this));\n            this._sendCommand('RCPT TO:<' + curRecipient + '>' + this._getDsnRcptToArgs());\n        }\n    }\n};\n\n/**\n * Handle response for a RCPT TO: command\n *\n * @param {String} str Message from the server\n */\nSMTPConnection.prototype._actionRCPT = function (str, callback) {\n    var message, err, curRecipient = this._recipientQueue.shift();\n    if (Number(str.charAt(0)) !== 2) {\n        // this is a soft error\n        if (this._usingSmtpUtf8 && /^553 /.test(str) && /[\\x80-\\uFFFF]/.test(curRecipient)) {\n            message = 'Internationalized mailbox name not allowed';\n        } else {\n            message = 'Recipient command failed';\n        }\n        this._envelope.rejected.push(curRecipient);\n        // store error for the failed recipient\n        err = this._formatError(message, 'EENVELOPE', str, 'RCPT TO');\n        err.recipient = curRecipient;\n        this._envelope.rejectedErrors.push(err);\n    } else {\n        this._envelope.accepted.push(curRecipient);\n    }\n\n    if (!this._envelope.rcptQueue.length && !this._recipientQueue.length) {\n        if (this._envelope.rejected.length < this._envelope.to.length) {\n            this._responseActions.push(function (str) {\n                this._actionDATA(str, callback);\n            }.bind(this));\n            this._sendCommand('DATA');\n        } else {\n            err = this._formatError('Can\\'t send mail - all recipients were rejected', 'EENVELOPE', str, 'RCPT TO');\n            err.rejected = this._envelope.rejected;\n            err.rejectedErrors = this._envelope.rejectedErrors;\n            return callback(err);\n        }\n    } else if (this._envelope.rcptQueue.length) {\n        curRecipient = this._envelope.rcptQueue.shift();\n        this._recipientQueue.push(curRecipient);\n        this._responseActions.push(function (str) {\n            this._actionRCPT(str, callback);\n        }.bind(this));\n        this._sendCommand('RCPT TO:<' + curRecipient + '>' + this._getDsnRcptToArgs());\n    }\n};\n\n/**\n * Handle response for a DATA command\n *\n * @param {String} str Message from the server\n */\nSMTPConnection.prototype._actionDATA = function (str, callback) {\n    // response should be 354 but according to this issue https://github.com/eleith/emailjs/issues/24\n    // some servers might use 250 instead, so lets check for 2 or 3 as the first digit\n    if ([2, 3].indexOf(Number(str.charAt(0))) < 0) {\n        return callback(this._formatError('Data command failed', 'EENVELOPE', str, 'DATA'));\n    }\n\n    var response = {\n        accepted: this._envelope.accepted,\n        rejected: this._envelope.rejected\n    };\n\n    if (this._envelope.rejectedErrors.length) {\n        response.rejectedErrors = this._envelope.rejectedErrors;\n    }\n\n    callback(null, response);\n};\n\n/**\n * Handle response for a DATA stream when using SMTP\n * We expect a single response that defines if the sending succeeded or failed\n *\n * @param {String} str Message from the server\n */\nSMTPConnection.prototype._actionSMTPStream = function (str, callback) {\n    if (Number(str.charAt(0)) !== 2) {\n        // Message failed\n        return callback(this._formatError('Message failed', 'EMESSAGE', str, 'DATA'));\n    } else {\n        // Message sent succesfully\n        return callback(null, str);\n    }\n};\n\n/**\n * Handle response for a DATA stream\n * We expect a separate response for every recipient. All recipients can either\n * succeed or fail separately\n *\n * @param {String} recipient The recipient this response applies to\n * @param {Boolean} final Is this the final recipient?\n * @param {String} str Message from the server\n */\nSMTPConnection.prototype._actionLMTPStream = function (recipient, final, str, callback) {\n    var err;\n    if (Number(str.charAt(0)) !== 2) {\n        // Message failed\n        err = this._formatError('Message failed for recipient ' + recipient, 'EMESSAGE', str, 'DATA');\n        err.recipient = recipient;\n        this._envelope.rejected.push(recipient);\n        this._envelope.rejectedErrors.push(err);\n        for (var i = 0, len = this._envelope.accepted.length; i < len; i++) {\n            if (this._envelope.accepted[i] === recipient) {\n                this._envelope.accepted.splice(i, 1);\n            }\n        }\n    }\n    if (final) {\n        return callback(null, str);\n    }\n};\n\nSMTPConnection.prototype._handleXOauth2Token = function (isRetry, callback) {\n    this._responseActions.push(function (str) {\n        this._actionAUTHComplete(str, isRetry, callback);\n    }.bind(this));\n\n    if (this._auth.xoauth2 && typeof this._auth.xoauth2 === 'object') {\n        this._auth.xoauth2[isRetry ? 'generateToken' : 'getToken'](function (err, token) {\n            if (err) {\n                this.logger.info('[%s] User %s failed to authenticate', this.id, JSON.stringify(this._user));\n                return callback(this._formatError(err, 'EAUTH', false, 'AUTH XOAUTH2'));\n            }\n            this._sendCommand('AUTH XOAUTH2 ' + token);\n        }.bind(this));\n    } else {\n        this._sendCommand('AUTH XOAUTH2 ' + this._buildXOAuth2Token(this._auth.user, this._auth.xoauth2));\n    }\n};\n\n/**\n * Builds a login token for XOAUTH2 authentication command\n *\n * @param {String} user E-mail address of the user\n * @param {String} token Valid access token for the user\n * @return {String} Base64 formatted login token\n */\nSMTPConnection.prototype._buildXOAuth2Token = function (user, token) {\n    var authData = [\n        'user=' + (user || ''),\n        'auth=Bearer ' + token,\n        '',\n        ''\n    ];\n    return new Buffer(authData.join('\\x01')).toString('base64');\n};\n\nSMTPConnection.prototype._getHostname = function () {\n    // defaul hostname is machine hostname or [IP]\n    var defaultHostname = os.hostname() || '';\n\n    // ignore if not FQDN\n    if (defaultHostname.indexOf('.') < 0) {\n        defaultHostname = '[127.0.0.1]';\n    }\n\n    // IP should be enclosed in []\n    if (defaultHostname.match(/^\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}$/)) {\n        defaultHostname = '[' + defaultHostname + ']';\n    }\n\n    return defaultHostname;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc210cC1jb25uZWN0aW9uL2xpYi9zbXRwLWNvbm5lY3Rpb24uanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsa0JBQWtCLG1CQUFPLENBQUMsMEVBQWlCO0FBQzNDLG1CQUFtQiwwREFBOEI7QUFDakQsV0FBVyxtQkFBTyxDQUFDLGtCQUFNO0FBQ3pCLFVBQVUsbUJBQU8sQ0FBQyxnQkFBSztBQUN2QixVQUFVLG1CQUFPLENBQUMsZ0JBQUs7QUFDdkIsU0FBUyxtQkFBTyxDQUFDLGNBQUk7QUFDckIsYUFBYSxtQkFBTyxDQUFDLHNCQUFRO0FBQzdCLGlCQUFpQixtQkFBTyxDQUFDLDhFQUFlO0FBQ3hDLGtCQUFrQix5REFBNkI7QUFDL0MsYUFBYSxtQkFBTyxDQUFDLCtFQUFtQjtBQUN4QyxXQUFXLG1CQUFPLENBQUMsNERBQWU7O0FBRWxDO0FBQ0Esd0NBQXdDO0FBQ3hDLHFDQUFxQztBQUNyQyxrQ0FBa0M7O0FBRWxDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsVUFBVTtBQUNWO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUSwyQkFBMkI7QUFDOUMsV0FBVyxRQUFRO0FBQ25CLFdBQVcsVUFBVTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSx3Q0FBd0MsU0FBUztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkNBQTZDO0FBQzdDLGdEQUFnRDs7QUFFaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQ0FBc0M7QUFDdEM7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUEsMkVBQTJFO0FBQzNFOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsdUJBQXVCO0FBQ3ZCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXO0FBQ1g7QUFDQSxXQUFXLE1BQU0seUJBQXlCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9EQUFvRCxTQUFTO0FBQzdEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNULE1BQU07QUFDTjtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMLDhDQUE4Qzs7QUFFOUM7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFNBQVM7QUFDcEIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCxTQUFTO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUNBQW1DLElBQUksS0FBSyxJQUFJLEtBQUssSUFBSSxLQUFLLElBQUk7QUFDbEU7QUFDQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbWV0YWJycy8uL25vZGVfbW9kdWxlcy9zbXRwLWNvbm5lY3Rpb24vbGliL3NtdHAtY29ubmVjdGlvbi5qcz85MGJkIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIHBhY2thZ2VJbmZvID0gcmVxdWlyZSgnLi4vcGFja2FnZS5qc29uJyk7XG52YXIgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xudmFyIHV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG52YXIgbmV0ID0gcmVxdWlyZSgnbmV0Jyk7XG52YXIgdGxzID0gcmVxdWlyZSgndGxzJyk7XG52YXIgb3MgPSByZXF1aXJlKCdvcycpO1xudmFyIGNyeXB0byA9IHJlcXVpcmUoJ2NyeXB0bycpO1xudmFyIERhdGFTdHJlYW0gPSByZXF1aXJlKCcuL2RhdGEtc3RyZWFtJyk7XG52YXIgUGFzc1Rocm91Z2ggPSByZXF1aXJlKCdzdHJlYW0nKS5QYXNzVGhyb3VnaDtcbnZhciBzaGFyZWQgPSByZXF1aXJlKCdub2RlbWFpbGVyLXNoYXJlZCcpO1xudmFyIG50bG0gPSByZXF1aXJlKCdodHRwbnRsbS9udGxtJyk7XG5cbi8vIGRlZmF1bHQgdGltZW91dCB2YWx1ZXMgaW4gbXNcbnZhciBDT05ORUNUSU9OX1RJTUVPVVQgPSAyICogNjAgKiAxMDAwOyAvLyBob3cgbXVjaCB0byB3YWl0IGZvciB0aGUgY29ubmVjdGlvbiB0byBiZSBlc3RhYmxpc2hlZFxudmFyIFNPQ0tFVF9USU1FT1VUID0gMTAgKiA2MCAqIDEwMDA7IC8vIGhvdyBtdWNoIHRvIHdhaXQgZm9yIHNvY2tldCBpbmFjdGl2aXR5IGJlZm9yZSBkaXNjb25uZWN0aW5nIHRoZSBjbGllbnRcbnZhciBHUkVFVElOR19USU1FT1VUID0gMzAgKiAxMDAwOyAvLyBob3cgbXVjaCB0byB3YWl0IGFmdGVyIGNvbm5lY3Rpb24gaXMgZXN0YWJsaXNoZWQgYnV0IFNNVFAgZ3JlZXRpbmcgaXMgbm90IHJlY2VpZXZlZFxuXG5tb2R1bGUuZXhwb3J0cyA9IFNNVFBDb25uZWN0aW9uO1xuXG4vKipcbiAqIEdlbmVyYXRlcyBhIFNNVFAgY29ubmVjdGlvbiBvYmplY3RcbiAqXG4gKiBPcHRpb25hbCBvcHRpb25zIG9iamVjdCB0YWtlcyB0aGUgZm9sbG93aW5nIHBvc3NpYmxlIHByb3BlcnRpZXM6XG4gKlxuICogICogKipwb3J0KiogLSBpcyB0aGUgcG9ydCB0byBjb25uZWN0IHRvIChkZWZhdWx0cyB0byAyNSBvciA0NjUpXG4gKiAgKiAqKmhvc3QqKiAtIGlzIHRoZSBob3N0bmFtZSBvciBJUCBhZGRyZXNzIHRvIGNvbm5lY3QgdG8gKGRlZmF1bHRzIHRvICdsb2NhbGhvc3QnKVxuICogICogKipzZWN1cmUqKiAtIHVzZSBTU0xcbiAqICAqICoqaWdub3JlVExTKiogLSBpZ25vcmUgc2VydmVyIHN1cHBvcnQgZm9yIFNUQVJUVExTXG4gKiAgKiAqKnJlcXVpcmVUTFMqKiAtIGZvcmNlcyB0aGUgY2xpZW50IHRvIHVzZSBTVEFSVFRMU1xuICogICogKipuYW1lKiogLSB0aGUgbmFtZSBvZiB0aGUgY2xpZW50IHNlcnZlclxuICogICogKipsb2NhbEFkZHJlc3MqKiAtIG91dGJvdW5kIGFkZHJlc3MgdG8gYmluZCB0byAoc2VlOiBodHRwOi8vbm9kZWpzLm9yZy9hcGkvbmV0Lmh0bWwjbmV0X25ldF9jb25uZWN0X29wdGlvbnNfY29ubmVjdGlvbmxpc3RlbmVyKVxuICogICogKipncmVldGluZ1RpbWVvdXQqKiAtIFRpbWUgdG8gd2FpdCBpbiBtcyB1bnRpbCBncmVldGluZyBtZXNzYWdlIGlzIHJlY2VpdmVkIGZyb20gdGhlIHNlcnZlciAoZGVmYXVsdHMgdG8gMTAwMDApXG4gKiAgKiAqKmNvbm5lY3Rpb25UaW1lb3V0KiogLSBob3cgbWFueSBtaWxsaXNlY29uZHMgdG8gd2FpdCBmb3IgdGhlIGNvbm5lY3Rpb24gdG8gZXN0YWJsaXNoXG4gKiAgKiAqKnNvY2tldFRpbWVvdXQqKiAtIFRpbWUgb2YgaW5hY3Rpdml0eSB1bnRpbCB0aGUgY29ubmVjdGlvbiBpcyBjbG9zZWQgKGRlZmF1bHRzIHRvIDEgaG91cilcbiAqICAqICoqbG10cCoqIC0gaWYgdHJ1ZSwgdXNlcyBMTVRQIGluc3RlYWQgb2YgU01UUCBwcm90b2NvbFxuICogICogKipsb2dnZXIqKiAtIGJ1bnlhbiBjb21wYXRpYmxlIGxvZ2dlciBpbnRlcmZhY2VcbiAqICAqICoqZGVidWcqKiAtIGlmIHRydWUgcGFzcyBTTVRQIHRyYWZmaWMgdG8gdGhlIGxvZ2dlclxuICogICogKip0bHMqKiAtIG9wdGlvbnMgZm9yIGNyZWF0ZUNyZWRlbnRpYWxzXG4gKiAgKiAqKnNvY2tldCoqIC0gZXhpc3Rpbmcgc29ja2V0IHRvIHVzZSBpbnN0ZWFkIG9mIGNyZWF0aW5nIGEgbmV3IG9uZSAoc2VlOiBodHRwOi8vbm9kZWpzLm9yZy9hcGkvbmV0Lmh0bWwjbmV0X2NsYXNzX25ldF9zb2NrZXQpXG4gKiAgKiAqKnNlY3VyZWQqKiAtIGJvb2xlYW4gaW5kaWNhdGVzIHRoYXQgdGhlIHByb3ZpZGVkIHNvY2tldCBoYXMgYWxyZWFkeSBiZWVuIHVwZ3JhZGVkIHRvIHRsc1xuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQG5hbWVzcGFjZSBTTVRQIENsaWVudCBtb2R1bGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9uIHByb3BlcnRpZXNcbiAqL1xuZnVuY3Rpb24gU01UUENvbm5lY3Rpb24ob3B0aW9ucykge1xuICAgIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xuXG4gICAgdGhpcy5pZCA9IGNyeXB0by5yYW5kb21CeXRlcyg4KS50b1N0cmluZygnYmFzZTY0JykucmVwbGFjZSgvXFxXL2csICcnKTtcbiAgICB0aGlzLnN0YWdlID0gJ2luaXQnO1xuXG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIHRoaXMuc2VjdXJlQ29ubmVjdGlvbiA9ICEhdGhpcy5vcHRpb25zLnNlY3VyZTtcbiAgICB0aGlzLmFscmVhZHlTZWN1cmVkID0gISF0aGlzLm9wdGlvbnMuc2VjdXJlZDtcblxuICAgIHRoaXMucG9ydCA9IHRoaXMub3B0aW9ucy5wb3J0IHx8ICh0aGlzLnNlY3VyZUNvbm5lY3Rpb24gPyA0NjUgOiAyNSk7XG4gICAgdGhpcy5ob3N0ID0gdGhpcy5vcHRpb25zLmhvc3QgfHwgJ2xvY2FsaG9zdCc7XG5cbiAgICBpZiAodHlwZW9mIHRoaXMub3B0aW9ucy5zZWN1cmUgPT09ICd1bmRlZmluZWQnICYmIHRoaXMucG9ydCA9PT0gNDY1KSB7XG4gICAgICAgIC8vIGlmIHNlY3VyZSBvcHRpb24gaXMgbm90IHNldCBidXQgcG9ydCBpcyA0NjUsIHRoZW4gZGVmYXVsdCB0byBzZWN1cmVcbiAgICAgICAgdGhpcy5zZWN1cmVDb25uZWN0aW9uID0gdHJ1ZTtcbiAgICB9XG5cbiAgICB0aGlzLm5hbWUgPSB0aGlzLm9wdGlvbnMubmFtZSB8fCB0aGlzLl9nZXRIb3N0bmFtZSgpO1xuXG4gICAgdGhpcy5sb2dnZXIgPSBzaGFyZWQuZ2V0TG9nZ2VyKHRoaXMub3B0aW9ucyk7XG5cbiAgICAvKipcbiAgICAgKiBFeHBvc2UgdmVyc2lvbiBuciwganVzdCBmb3IgdGhlIHJlZmVyZW5jZVxuICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy52ZXJzaW9uID0gcGFja2FnZUluZm8udmVyc2lvbjtcblxuICAgIC8qKlxuICAgICAqIElmIHRydWUsIHRoZW4gdGhlIHVzZXIgaXMgYXV0aGVudGljYXRlZFxuICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuYXV0aGVudGljYXRlZCA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogSWYgc2V0IHRvIHRydWUsIHRoaXMgaW5zdGFuY2UgaXMgbm8gbG9uZ2VyIGFjdGl2ZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIERlZmluZXMgaWYgdGhlIGN1cnJlbnQgY29ubmVjdGlvbiBpcyBzZWN1cmUgb3Igbm90LiBJZiBub3QsXG4gICAgICogU1RBUlRUTFMgY2FuIGJlIHVzZWQgaWYgYXZhaWxhYmxlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLnNlY3VyZSA9ICEhdGhpcy5zZWN1cmVDb25uZWN0aW9uO1xuXG4gICAgLyoqXG4gICAgICogU3RvcmUgaW5jb21wbGV0ZSBtZXNzYWdlcyBjb21pbmcgZnJvbSB0aGUgc2VydmVyXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9yZW1haW5kZXIgPSAnJztcblxuICAgIC8qKlxuICAgICAqIFVucHJvY2Vzc2VkIHJlc3BvbnNlcyBmcm9tIHRoZSBzZXJ2ZXJcbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICovXG4gICAgdGhpcy5fcmVzcG9uc2VRdWV1ZSA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHNvY2tldCBjb25uZWN0aW5nIHRvIHRoZSBzZXJ2ZXJcbiAgICAgKiBAcHVibGlja1xuICAgICAqL1xuICAgIHRoaXMuX3NvY2tldCA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogTGlzdHMgc3VwcG9ydGVkIGF1dGggbWVjaGFuaXNtc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fc3VwcG9ydGVkQXV0aCA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogSW5jbHVkZXMgY3VycmVudCBlbnZlbG9wZSAoZnJvbSwgdG8pXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9lbnZlbG9wZSA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogTGlzdHMgc3VwcG9ydGVkIGV4dGVuc2lvbnNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX3N1cHBvcnRlZEV4dGVuc2lvbnMgPSBbXTtcblxuICAgIC8qKlxuICAgICAqIERlZmluZXMgdGhlIG1heGltdW0gYWxsb3dlZCBzaXplIGZvciBhIHNpbmdsZSBtZXNzYWdlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9tYXhBbGxvd2VkU2l6ZSA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBGdW5jdGlvbiBxdWV1ZSB0byBydW4gaWYgYSBkYXRhIGNodW5rIGNvbWVzIGZyb20gdGhlIHNlcnZlclxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fcmVzcG9uc2VBY3Rpb25zID0gW107XG4gICAgdGhpcy5fcmVjaXBpZW50UXVldWUgPSBbXTtcblxuICAgIC8qKlxuICAgICAqIFRpbWVvdXQgdmFyaWFibGUgZm9yIHdhaXRpbmcgdGhlIGdyZWV0aW5nXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9ncmVldGluZ1RpbWVvdXQgPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIFRpbWVvdXQgdmFyaWFibGUgZm9yIHdhaXRpbmcgdGhlIGNvbm5lY3Rpb24gdG8gc3RhcnRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX2Nvbm5lY3Rpb25UaW1lb3V0ID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBJZiB0aGUgc29ja2V0IGlzIGRlZW1lZCBhbHJlYWR5IGNsb3NlZFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fZGVzdHJveWVkID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBJZiB0aGUgc29ja2V0IGlzIGFscmVhZHkgYmVpbmcgY2xvc2VkXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9jbG9zaW5nID0gZmFsc2U7XG59XG51dGlsLmluaGVyaXRzKFNNVFBDb25uZWN0aW9uLCBFdmVudEVtaXR0ZXIpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBjb25uZWN0aW9uIHRvIGEgU01UUCBzZXJ2ZXIgYW5kIHNldHMgdXAgY29ubmVjdGlvblxuICogbGlzdGVuZXJcbiAqL1xuU01UUENvbm5lY3Rpb24ucHJvdG90eXBlLmNvbm5lY3QgPSBmdW5jdGlvbiAoY29ubmVjdENhbGxiYWNrKSB7XG4gICAgaWYgKHR5cGVvZiBjb25uZWN0Q2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhpcy5vbmNlKCdjb25uZWN0JywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIuZGVidWcoJ1slc10gU01UUCBoYW5kc2hha2UgZmluaXNoZWQnLCB0aGlzLmlkKTtcbiAgICAgICAgICAgIGNvbm5lY3RDYWxsYmFjaygpO1xuICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgIH1cblxuICAgIHZhciBvcHRzID0ge1xuICAgICAgICBwb3J0OiB0aGlzLnBvcnQsXG4gICAgICAgIGhvc3Q6IHRoaXMuaG9zdFxuICAgIH07XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLmxvY2FsQWRkcmVzcykge1xuICAgICAgICBvcHRzLmxvY2FsQWRkcmVzcyA9IHRoaXMub3B0aW9ucy5sb2NhbEFkZHJlc3M7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5jb25uZWN0aW9uKSB7XG4gICAgICAgIC8vIGNvbm5lY3Rpb24gaXMgYWxyZWFkeSBvcGVuZWRcbiAgICAgICAgdGhpcy5fc29ja2V0ID0gdGhpcy5vcHRpb25zLmNvbm5lY3Rpb247XG4gICAgICAgIGlmICh0aGlzLnNlY3VyZUNvbm5lY3Rpb24gJiYgIXRoaXMuYWxyZWFkeVNlY3VyZWQpIHtcbiAgICAgICAgICAgIHNldEltbWVkaWF0ZSh0aGlzLl91cGdyYWRlQ29ubmVjdGlvbi5iaW5kKHRoaXMsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX29uRXJyb3IobmV3IEVycm9yKCdFcnJvciBpbml0aWF0aW5nIFRMUyAtICcgKyAoZXJyLm1lc3NhZ2UgfHwgZXJyKSksICdFVExTJywgZmFsc2UsICdDT05OJyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5fb25Db25uZWN0KCk7XG4gICAgICAgICAgICB9LmJpbmQodGhpcykpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNldEltbWVkaWF0ZSh0aGlzLl9vbkNvbm5lY3QuYmluZCh0aGlzKSk7XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRoaXMub3B0aW9ucy5zb2NrZXQpIHtcbiAgICAgICAgLy8gc29ja2V0IG9iamVjdCBpcyBzZXQgdXAgYnV0IG5vdCB5ZXQgY29ubmVjdGVkXG4gICAgICAgIHRoaXMuX3NvY2tldCA9IHRoaXMub3B0aW9ucy5zb2NrZXQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLl9zb2NrZXQuY29ubmVjdCh0aGlzLnBvcnQsIHRoaXMuaG9zdCwgdGhpcy5fb25Db25uZWN0LmJpbmQodGhpcykpO1xuICAgICAgICB9IGNhdGNoIChFKSB7XG4gICAgICAgICAgICByZXR1cm4gc2V0SW1tZWRpYXRlKHRoaXMuX29uRXJyb3IuYmluZCh0aGlzLCBFLCAnRUNPTk5FQ1RJT04nLCBmYWxzZSwgJ0NPTk4nKSk7XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRoaXMuc2VjdXJlQ29ubmVjdGlvbikge1xuICAgICAgICAvLyBjb25uZWN0IHVzaW5nIHRsc1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnRscykge1xuICAgICAgICAgICAgT2JqZWN0LmtleXModGhpcy5vcHRpb25zLnRscykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgb3B0c1trZXldID0gdGhpcy5vcHRpb25zLnRsc1trZXldO1xuICAgICAgICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5fc29ja2V0ID0gdGxzLmNvbm5lY3QodGhpcy5wb3J0LCB0aGlzLmhvc3QsIG9wdHMsIHRoaXMuX29uQ29ubmVjdC5iaW5kKHRoaXMpKTtcbiAgICAgICAgfSBjYXRjaCAoRSkge1xuICAgICAgICAgICAgcmV0dXJuIHNldEltbWVkaWF0ZSh0aGlzLl9vbkVycm9yLmJpbmQodGhpcywgRSwgJ0VDT05ORUNUSU9OJywgZmFsc2UsICdDT05OJykpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gY29ubmVjdCB1c2luZyBwbGFpbnRleHRcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuX3NvY2tldCA9IG5ldC5jb25uZWN0KG9wdHMsIHRoaXMuX29uQ29ubmVjdC5iaW5kKHRoaXMpKTtcbiAgICAgICAgfSBjYXRjaCAoRSkge1xuICAgICAgICAgICAgcmV0dXJuIHNldEltbWVkaWF0ZSh0aGlzLl9vbkVycm9yLmJpbmQodGhpcywgRSwgJ0VDT05ORUNUSU9OJywgZmFsc2UsICdDT05OJykpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5fY29ubmVjdGlvblRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fb25FcnJvcignQ29ubmVjdGlvbiB0aW1lb3V0JywgJ0VUSU1FRE9VVCcsIGZhbHNlLCAnQ09OTicpO1xuICAgIH0uYmluZCh0aGlzKSwgdGhpcy5vcHRpb25zLmNvbm5lY3Rpb25UaW1lb3V0IHx8IENPTk5FQ1RJT05fVElNRU9VVCk7XG5cbiAgICB0aGlzLl9zb2NrZXQub24oJ2Vycm9yJywgZnVuY3Rpb24gKGVycikge1xuICAgICAgICB0aGlzLl9vbkVycm9yKGVyciwgJ0VDT05ORUNUSU9OJywgZmFsc2UsICdDT05OJyk7XG4gICAgfS5iaW5kKHRoaXMpKTtcbn07XG5cbi8qKlxuICogU2VuZHMgUVVJVFxuICovXG5TTVRQQ29ubmVjdGlvbi5wcm90b3R5cGUucXVpdCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9zZW5kQ29tbWFuZCgnUVVJVCcpO1xuICAgIHRoaXMuX3Jlc3BvbnNlQWN0aW9ucy5wdXNoKHRoaXMuY2xvc2UpO1xufTtcblxuLyoqXG4gKiBDbG9zZXMgdGhlIGNvbm5lY3Rpb24gdG8gdGhlIHNlcnZlclxuICovXG5TTVRQQ29ubmVjdGlvbi5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMuX2Nvbm5lY3Rpb25UaW1lb3V0KTtcbiAgICBjbGVhclRpbWVvdXQodGhpcy5fZ3JlZXRpbmdUaW1lb3V0KTtcbiAgICB0aGlzLl9yZXNwb25zZUFjdGlvbnMgPSBbXTtcblxuICAgIC8vIGFsbG93IHRvIHJ1biB0aGlzIGZ1bmN0aW9uIG9ubHkgb25jZVxuICAgIGlmICh0aGlzLl9jbG9zaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fY2xvc2luZyA9IHRydWU7XG5cbiAgICB2YXIgY2xvc2VNZXRob2QgPSAnZW5kJztcblxuICAgIGlmICh0aGlzLnN0YWdlID09PSAnaW5pdCcpIHtcbiAgICAgICAgLy8gQ2xvc2UgdGhlIHNvY2tldCBpbW1lZGlhdGVseSB3aGVuIGNvbm5lY3Rpb24gdGltZWQgb3V0XG4gICAgICAgIGNsb3NlTWV0aG9kID0gJ2Rlc3Ryb3knO1xuICAgIH1cblxuICAgIHRoaXMubG9nZ2VyLmRlYnVnKCdbJXNdIENsb3NpbmcgY29ubmVjdGlvbiB0byB0aGUgc2VydmVyIHVzaW5nIFwiJXNcIicsIHRoaXMuaWQsIGNsb3NlTWV0aG9kKTtcblxuICAgIHZhciBzb2NrZXQgPSB0aGlzLl9zb2NrZXQgJiYgdGhpcy5fc29ja2V0LnNvY2tldCB8fCB0aGlzLl9zb2NrZXQ7XG5cbiAgICBpZiAoc29ja2V0ICYmICFzb2NrZXQuZGVzdHJveWVkKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLl9zb2NrZXRbY2xvc2VNZXRob2RdKCk7XG4gICAgICAgIH0gY2F0Y2ggKEUpIHtcbiAgICAgICAgICAgIC8vIGp1c3QgaWdub3JlXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLl9kZXN0cm95KCk7XG59O1xuXG4vKipcbiAqIEF1dGhlbnRpY2F0ZSB1c2VyXG4gKi9cblNNVFBDb25uZWN0aW9uLnByb3RvdHlwZS5sb2dpbiA9IGZ1bmN0aW9uIChhdXRoRGF0YSwgY2FsbGJhY2spIHtcbiAgICB0aGlzLl9hdXRoID0gYXV0aERhdGEgfHwge307XG4gICAgdGhpcy5fdXNlciA9IHRoaXMuX2F1dGgueG9hdXRoMiAmJiB0aGlzLl9hdXRoLnhvYXV0aDIub3B0aW9ucyAmJiB0aGlzLl9hdXRoLnhvYXV0aDIub3B0aW9ucy51c2VyIHx8IHRoaXMuX2F1dGgudXNlciB8fCAnJztcblxuICAgIHRoaXMuX2F1dGhNZXRob2QgPSBmYWxzZTtcbiAgICBpZiAodGhpcy5vcHRpb25zLmF1dGhNZXRob2QpIHtcbiAgICAgICAgdGhpcy5fYXV0aE1ldGhvZCA9IHRoaXMub3B0aW9ucy5hdXRoTWV0aG9kLnRvVXBwZXJDYXNlKCkudHJpbSgpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5fYXV0aC54b2F1dGgyICYmIHRoaXMuX3N1cHBvcnRlZEF1dGguaW5kZXhPZignWE9BVVRIMicpID49IDApIHtcbiAgICAgICAgdGhpcy5fYXV0aE1ldGhvZCA9ICdYT0FVVEgyJztcbiAgICB9IGVsc2UgaWYgKHRoaXMuX2F1dGguZG9tYWluICYmIHRoaXMuX3N1cHBvcnRlZEF1dGguaW5kZXhPZignTlRMTScpID49IDApIHtcbiAgICAgICAgdGhpcy5fYXV0aE1ldGhvZCA9ICdOVExNJztcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyB1c2UgZmlyc3Qgc3VwcG9ydGVkXG4gICAgICAgIHRoaXMuX2F1dGhNZXRob2QgPSAodGhpcy5fc3VwcG9ydGVkQXV0aFswXSB8fCAnUExBSU4nKS50b1VwcGVyQ2FzZSgpLnRyaW0oKTtcbiAgICB9XG5cbiAgICBzd2l0Y2ggKHRoaXMuX2F1dGhNZXRob2QpIHtcbiAgICAgICAgY2FzZSAnWE9BVVRIMic6XG4gICAgICAgICAgICB0aGlzLl9oYW5kbGVYT2F1dGgyVG9rZW4oZmFsc2UsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY2FzZSAnTE9HSU4nOlxuICAgICAgICAgICAgdGhpcy5fcmVzcG9uc2VBY3Rpb25zLnB1c2goZnVuY3Rpb24gKHN0cikge1xuICAgICAgICAgICAgICAgIHRoaXMuX2FjdGlvbkFVVEhfTE9HSU5fVVNFUihzdHIsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgICAgICAgICB0aGlzLl9zZW5kQ29tbWFuZCgnQVVUSCBMT0dJTicpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjYXNlICdQTEFJTic6XG4gICAgICAgICAgICB0aGlzLl9yZXNwb25zZUFjdGlvbnMucHVzaChmdW5jdGlvbiAoc3RyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYWN0aW9uQVVUSENvbXBsZXRlKHN0ciwgY2FsbGJhY2spO1xuICAgICAgICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICAgICAgICAgIHRoaXMuX3NlbmRDb21tYW5kKCdBVVRIIFBMQUlOICcgKyBuZXcgQnVmZmVyKFxuICAgICAgICAgICAgICAgIC8vdGhpcy5fYXV0aC51c2VyKydcXHUwMDAwJytcbiAgICAgICAgICAgICAgICAnXFx1MDAwMCcgKyAvLyBza2lwIGF1dGhvcml6YXRpb24gaWRlbnRpdHkgYXMgaXQgY2F1c2VzIHByb2JsZW1zIHdpdGggc29tZSBzZXJ2ZXJzXG4gICAgICAgICAgICAgICAgdGhpcy5fYXV0aC51c2VyICsgJ1xcdTAwMDAnICtcbiAgICAgICAgICAgICAgICB0aGlzLl9hdXRoLnBhc3MsICd1dGYtOCcpLnRvU3RyaW5nKCdiYXNlNjQnKSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNhc2UgJ0NSQU0tTUQ1JzpcbiAgICAgICAgICAgIHRoaXMuX3Jlc3BvbnNlQWN0aW9ucy5wdXNoKGZ1bmN0aW9uIChzdHIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9hY3Rpb25BVVRIX0NSQU1fTUQ1KHN0ciwgY2FsbGJhY2spO1xuICAgICAgICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICAgICAgICAgIHRoaXMuX3NlbmRDb21tYW5kKCdBVVRIIENSQU0tTUQ1Jyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNhc2UgJ05UTE0nOlxuICAgICAgICAgICAgdGhpcy5fcmVzcG9uc2VBY3Rpb25zLnB1c2goZnVuY3Rpb24gKHN0cikge1xuICAgICAgICAgICAgICAgIHRoaXMuX2FjdGlvbkFVVEhfTlRMTV9UWVBFMShzdHIsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgICAgICAgICB0aGlzLl9zZW5kQ29tbWFuZCgnQVVUSCAnICsgbnRsbS5jcmVhdGVUeXBlMU1lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgIGRvbWFpbjogdGhpcy5fYXV0aC5kb21haW4gfHwgJycsXG4gICAgICAgICAgICAgICAgd29ya3N0YXRpb246IHRoaXMuX2F1dGgud29ya3N0YXRpb24gfHwgJydcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICByZXR1cm4gY2FsbGJhY2sodGhpcy5fZm9ybWF0RXJyb3IoJ1Vua25vd24gYXV0aGVudGljYXRpb24gbWV0aG9kIFwiJyArIHRoaXMuX2F1dGhNZXRob2QgKyAnXCInLCAnRUFVVEgnLCBmYWxzZSwgJ0FQSScpKTtcbn07XG5cbi8qKlxuICogU2VuZHMgYSBtZXNzYWdlXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGVudmVsb3BlIEVudmVsb3BlIG9iamVjdCwge2Zyb206IGFkZHIsIHRvOiBbYWRkcl19XG4gKiBAcGFyYW0ge09iamVjdH0gbWVzc2FnZSBTdHJpbmcsIEJ1ZmZlciBvciBhIFN0cmVhbVxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2sgdG8gcmV0dXJuIG9uY2Ugc2VuZGluZyBpcyBjb21wbGV0ZWRcbiAqL1xuU01UUENvbm5lY3Rpb24ucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbiAoZW52ZWxvcGUsIG1lc3NhZ2UsIGRvbmUpIHtcbiAgICBpZiAoIW1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIGRvbmUodGhpcy5fZm9ybWF0RXJyb3IoJ0VtcHR5IG1lc3NhZ2UnLCAnRU1FU1NBR0UnLCBmYWxzZSwgJ0FQSScpKTtcbiAgICB9XG5cbiAgICAvLyByZWplY3QgbGFyZ2VyIG1lc3NhZ2VzIHRoYW4gYWxsb3dlZFxuICAgIGlmICh0aGlzLl9tYXhBbGxvd2VkU2l6ZSAmJiBlbnZlbG9wZS5zaXplID4gdGhpcy5fbWF4QWxsb3dlZFNpemUpIHtcbiAgICAgICAgcmV0dXJuIHNldEltbWVkaWF0ZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBkb25lKHRoaXMuX2Zvcm1hdEVycm9yKCdNZXNzYWdlIHNpemUgbGFyZ2VyIHRoYW4gYWxsb3dlZCAnICsgdGhpcy5fbWF4QWxsb3dlZFNpemUsICdFTUVTU0FHRScsIGZhbHNlLCAnTUFJTCBGUk9NJykpO1xuICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgIH1cblxuICAgIC8vIGVuc3VyZSB0aGF0IGNhbGxiYWNrIGlzIG9ubHkgY2FsbGVkIG9uY2VcbiAgICB2YXIgcmV0dXJuZWQgPSBmYWxzZTtcbiAgICB2YXIgY2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChyZXR1cm5lZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybmVkID0gdHJ1ZTtcblxuICAgICAgICBkb25lLmFwcGx5KG51bGwsIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cykpO1xuICAgIH07XG5cbiAgICBpZiAodHlwZW9mIG1lc3NhZ2Uub24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgbWVzc2FnZS5vbignZXJyb3InLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2sodGhpcy5fZm9ybWF0RXJyb3IoZXJyLCAnRVNUUkVBTScsIGZhbHNlLCAnQVBJJykpO1xuICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgIH1cblxuICAgIHRoaXMuX3NldEVudmVsb3BlKGVudmVsb3BlLCBmdW5jdGlvbiAoZXJyLCBpbmZvKSB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzdHJlYW0gPSB0aGlzLl9jcmVhdGVTZW5kU3RyZWFtKGZ1bmN0aW9uIChlcnIsIHN0cikge1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW5mby5yZXNwb25zZSA9IHN0cjtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCBpbmZvKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZS5waXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBtZXNzYWdlLnBpcGUoc3RyZWFtKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0cmVhbS53cml0ZShtZXNzYWdlKTtcbiAgICAgICAgICAgIHN0cmVhbS5lbmQoKTtcbiAgICAgICAgfVxuXG4gICAgfS5iaW5kKHRoaXMpKTtcbn07XG5cbi8qKlxuICogUmVzZXRzIGNvbm5lY3Rpb24gc3RhdGVcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFjayB0byByZXR1cm4gb25jZSBjb25uZWN0aW9uIGlzIHJlc2V0XG4gKi9cblNNVFBDb25uZWN0aW9uLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgIHRoaXMuX3NlbmRDb21tYW5kKCdSU0VUJyk7XG4gICAgdGhpcy5fcmVzcG9uc2VBY3Rpb25zLnB1c2goZnVuY3Rpb24gKHN0cikge1xuICAgICAgICBpZiAoc3RyLmNoYXJBdCgwKSAhPT0gJzInKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2sodGhpcy5fZm9ybWF0RXJyb3IoJ0NvdWxkIG5vdCByZXNldCBzZXNzaW9uIHN0YXRlOlxcbicgKyBzdHIsICdFUFJPVE9DT0wnLCBzdHIsICdSU0VUJykpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2VudmVsb3BlID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCB0cnVlKTtcbiAgICB9LmJpbmQodGhpcykpO1xufTtcblxuLyoqXG4gKiBDb25uZWN0aW9uIGxpc3RlbmVyIHRoYXQgaXMgcnVuIHdoZW4gdGhlIGNvbm5lY3Rpb24gdG9cbiAqIHRoZSBzZXJ2ZXIgaXMgb3BlbmVkXG4gKlxuICogQGV2ZW50XG4gKi9cblNNVFBDb25uZWN0aW9uLnByb3RvdHlwZS5fb25Db25uZWN0ID0gZnVuY3Rpb24gKCkge1xuICAgIGNsZWFyVGltZW91dCh0aGlzLl9jb25uZWN0aW9uVGltZW91dCk7XG5cbiAgICB0aGlzLmxvZ2dlci5pbmZvKCdbJXNdICVzIGVzdGFibGlzaGVkIHRvICVzOiVzJywgdGhpcy5pZCwgdGhpcy5zZWN1cmUgPyAnU2VjdXJlIGNvbm5lY3Rpb24nIDogJ0Nvbm5lY3Rpb24nLCB0aGlzLl9zb2NrZXQucmVtb3RlQWRkcmVzcywgdGhpcy5fc29ja2V0LnJlbW90ZVBvcnQpO1xuXG4gICAgaWYgKHRoaXMuX2Rlc3Ryb3llZCkge1xuICAgICAgICAvLyBDb25uZWN0aW9uIHdhcyBlc3RhYmxpc2hlZCBhZnRlciB3ZSBhbHJlYWR5IGhhZCBjYW5jZWxlZCBpdFxuICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLnN0YWdlID0gJ2Nvbm5lY3RlZCc7XG5cbiAgICAvLyBjbGVhciBleGlzdGluZyBsaXN0ZW5lcnMgZm9yIHRoZSBzb2NrZXRcbiAgICB0aGlzLl9zb2NrZXQucmVtb3ZlQWxsTGlzdGVuZXJzKCdkYXRhJyk7XG4gICAgdGhpcy5fc29ja2V0LnJlbW92ZUFsbExpc3RlbmVycygndGltZW91dCcpO1xuICAgIHRoaXMuX3NvY2tldC5yZW1vdmVBbGxMaXN0ZW5lcnMoJ2Nsb3NlJyk7XG4gICAgdGhpcy5fc29ja2V0LnJlbW92ZUFsbExpc3RlbmVycygnZW5kJyk7XG5cbiAgICB0aGlzLl9zb2NrZXQub24oJ2RhdGEnLCB0aGlzLl9vbkRhdGEuYmluZCh0aGlzKSk7XG4gICAgdGhpcy5fc29ja2V0Lm9uY2UoJ2Nsb3NlJywgdGhpcy5fb25DbG9zZS5iaW5kKHRoaXMpKTtcbiAgICB0aGlzLl9zb2NrZXQub25jZSgnZW5kJywgdGhpcy5fb25FbmQuYmluZCh0aGlzKSk7XG5cbiAgICB0aGlzLl9zb2NrZXQuc2V0VGltZW91dCh0aGlzLm9wdGlvbnMuc29ja2V0VGltZW91dCB8fCBTT0NLRVRfVElNRU9VVCk7XG4gICAgdGhpcy5fc29ja2V0Lm9uKCd0aW1lb3V0JywgdGhpcy5fb25UaW1lb3V0LmJpbmQodGhpcykpO1xuXG4gICAgdGhpcy5fZ3JlZXRpbmdUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIGlmIHN0aWxsIHdhaXRpbmcgZm9yIGdyZWV0aW5nLCBnaXZlIHVwXG4gICAgICAgIGlmICh0aGlzLl9zb2NrZXQgJiYgIXRoaXMuX2Rlc3Ryb3llZCAmJiB0aGlzLl9yZXNwb25zZUFjdGlvbnNbMF0gPT09IHRoaXMuX2FjdGlvbkdyZWV0aW5nKSB7XG4gICAgICAgICAgICB0aGlzLl9vbkVycm9yKCdHcmVldGluZyBuZXZlciByZWNlaXZlZCcsICdFVElNRURPVVQnLCBmYWxzZSwgJ0NPTk4nKTtcbiAgICAgICAgfVxuICAgIH0uYmluZCh0aGlzKSwgdGhpcy5vcHRpb25zLmdyZWV0aW5nVGltZW91dCB8fCBHUkVFVElOR19USU1FT1VUKTtcblxuICAgIHRoaXMuX3Jlc3BvbnNlQWN0aW9ucy5wdXNoKHRoaXMuX2FjdGlvbkdyZWV0aW5nKTtcblxuICAgIC8vIHdlIGhhdmUgYSAnZGF0YScgbGlzdGVuZXIgc2V0IHVwIHNvIHJlc3VtZSBzb2NrZXQgaWYgaXQgd2FzIHBhdXNlZFxuICAgIHRoaXMuX3NvY2tldC5yZXN1bWUoKTtcbn07XG5cbi8qKlxuICogJ2RhdGEnIGxpc3RlbmVyIGZvciBkYXRhIGNvbWluZyBmcm9tIHRoZSBzZXJ2ZXJcbiAqXG4gKiBAZXZlbnRcbiAqIEBwYXJhbSB7QnVmZmVyfSBjaHVuayBEYXRhIGNodW5rIGNvbWluZyBmcm9tIHRoZSBzZXJ2ZXJcbiAqL1xuU01UUENvbm5lY3Rpb24ucHJvdG90eXBlLl9vbkRhdGEgPSBmdW5jdGlvbiAoY2h1bmspIHtcbiAgICBpZiAodGhpcy5fZGVzdHJveWVkIHx8ICFjaHVuayB8fCAhY2h1bmsubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgZGF0YSA9IChjaHVuayB8fCAnJykudG9TdHJpbmcoJ2JpbmFyeScpO1xuICAgIHZhciBsaW5lcyA9ICh0aGlzLl9yZW1haW5kZXIgKyBkYXRhKS5zcGxpdCgvXFxyP1xcbi8pO1xuICAgIHZhciBsYXN0bGluZTtcblxuICAgIHRoaXMuX3JlbWFpbmRlciA9IGxpbmVzLnBvcCgpO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGxpbmVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGlmICh0aGlzLl9yZXNwb25zZVF1ZXVlLmxlbmd0aCkge1xuICAgICAgICAgICAgbGFzdGxpbmUgPSB0aGlzLl9yZXNwb25zZVF1ZXVlW3RoaXMuX3Jlc3BvbnNlUXVldWUubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICBpZiAoL15cXGQrXFwtLy50ZXN0KGxhc3RsaW5lLnNwbGl0KCdcXG4nKS5wb3AoKSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZXNwb25zZVF1ZXVlW3RoaXMuX3Jlc3BvbnNlUXVldWUubGVuZ3RoIC0gMV0gKz0gJ1xcbicgKyBsaW5lc1tpXTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9yZXNwb25zZVF1ZXVlLnB1c2gobGluZXNbaV0pO1xuICAgIH1cblxuICAgIHRoaXMuX3Byb2Nlc3NSZXNwb25zZSgpO1xufTtcblxuLyoqXG4gKiAnZXJyb3InIGxpc3RlbmVyIGZvciB0aGUgc29ja2V0XG4gKlxuICogQGV2ZW50XG4gKiBAcGFyYW0ge0Vycm9yfSBlcnIgRXJyb3Igb2JqZWN0XG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBFcnJvciBuYW1lXG4gKi9cblNNVFBDb25uZWN0aW9uLnByb3RvdHlwZS5fb25FcnJvciA9IGZ1bmN0aW9uIChlcnIsIHR5cGUsIGRhdGEsIGNvbW1hbmQpIHtcbiAgICBjbGVhclRpbWVvdXQodGhpcy5fY29ubmVjdGlvblRpbWVvdXQpO1xuICAgIGNsZWFyVGltZW91dCh0aGlzLl9ncmVldGluZ1RpbWVvdXQpO1xuXG4gICAgaWYgKHRoaXMuX2Rlc3Ryb3llZCkge1xuICAgICAgICAvLyBqdXN0IGlnbm9yZSwgYWxyZWFkeSBjbG9zZWRcbiAgICAgICAgLy8gdGhpcyBtaWdodCBoYXBwZW4gd2hlbiBhIHNvY2tldCBpcyBjYW5jZWxlZCBiZWNhdXNlIG9mIHJlYWNoZWQgdGltZW91dFxuICAgICAgICAvLyBidXQgdGhlIHNvY2tldCB0aW1lb3V0IGVycm9yIGl0c2VsZiByZWNlaXZlcyBvbmx5IGFmdGVyXG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBlcnIgPSB0aGlzLl9mb3JtYXRFcnJvcihlcnIsIHR5cGUsIGRhdGEsIGNvbW1hbmQpO1xuXG4gICAgdGhpcy5sb2dnZXIuZXJyb3IoJ1slc10gJXMnLCB0aGlzLmlkLCBlcnIubWVzc2FnZSk7XG5cbiAgICB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgICB0aGlzLmNsb3NlKCk7XG59O1xuXG5TTVRQQ29ubmVjdGlvbi5wcm90b3R5cGUuX2Zvcm1hdEVycm9yID0gZnVuY3Rpb24gKG1lc3NhZ2UsIHR5cGUsIHJlc3BvbnNlLCBjb21tYW5kKSB7XG4gICAgdmFyIGVycjtcblxuICAgIGlmICgvRXJyb3JcXF0kL2kudGVzdChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobWVzc2FnZSkpKSB7XG4gICAgICAgIGVyciA9IG1lc3NhZ2U7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZXJyID0gbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgIH1cblxuICAgIGlmICh0eXBlICYmIHR5cGUgIT09ICdFcnJvcicpIHtcbiAgICAgICAgZXJyLmNvZGUgPSB0eXBlO1xuICAgIH1cblxuICAgIGlmIChyZXNwb25zZSkge1xuICAgICAgICBlcnIucmVzcG9uc2UgPSByZXNwb25zZTtcbiAgICAgICAgZXJyLm1lc3NhZ2UgKz0gJzogJyArIHJlc3BvbnNlO1xuICAgIH1cblxuICAgIHZhciByZXNwb25zZUNvZGUgPSB0eXBlb2YgcmVzcG9uc2UgPT09ICdzdHJpbmcnICYmIE51bWJlcigocmVzcG9uc2UubWF0Y2goL15cXGQrLykgfHwgW10pWzBdKSB8fCBmYWxzZTtcbiAgICBpZiAocmVzcG9uc2VDb2RlKSB7XG4gICAgICAgIGVyci5yZXNwb25zZUNvZGUgPSByZXNwb25zZUNvZGU7XG4gICAgfVxuXG4gICAgaWYgKGNvbW1hbmQpIHtcbiAgICAgICAgZXJyLmNvbW1hbmQgPSBjb21tYW5kO1xuICAgIH1cblxuICAgIHJldHVybiBlcnI7XG59O1xuXG4vKipcbiAqICdjbG9zZScgbGlzdGVuZXIgZm9yIHRoZSBzb2NrZXRcbiAqXG4gKiBAZXZlbnRcbiAqL1xuU01UUENvbm5lY3Rpb24ucHJvdG90eXBlLl9vbkNsb3NlID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMubG9nZ2VyLmluZm8oJ1slc10gQ29ubmVjdGlvbiBjbG9zZWQnLCB0aGlzLmlkKTtcblxuICAgIGlmIChbdGhpcy5fYWN0aW9uR3JlZXRpbmcsIHRoaXMuY2xvc2VdLmluZGV4T2YodGhpcy5fcmVzcG9uc2VBY3Rpb25zWzBdKSA8IDAgJiYgIXRoaXMuX2Rlc3Ryb3llZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fb25FcnJvcihuZXcgRXJyb3IoJ0Nvbm5lY3Rpb24gY2xvc2VkIHVuZXhwZWN0ZWRseScpLCAnRUNPTk5FQ1RJT04nLCBmYWxzZSwgJ0NPTk4nKTtcbiAgICB9XG5cbiAgICB0aGlzLl9kZXN0cm95KCk7XG59O1xuXG4vKipcbiAqICdlbmQnIGxpc3RlbmVyIGZvciB0aGUgc29ja2V0XG4gKlxuICogQGV2ZW50XG4gKi9cblNNVFBDb25uZWN0aW9uLnByb3RvdHlwZS5fb25FbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fZGVzdHJveSgpO1xufTtcblxuLyoqXG4gKiAndGltZW91dCcgbGlzdGVuZXIgZm9yIHRoZSBzb2NrZXRcbiAqXG4gKiBAZXZlbnRcbiAqL1xuU01UUENvbm5lY3Rpb24ucHJvdG90eXBlLl9vblRpbWVvdXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX29uRXJyb3IobmV3IEVycm9yKCdUaW1lb3V0JyksICdFVElNRURPVVQnLCBmYWxzZSwgJ0NPTk4nKTtcbn07XG5cbi8qKlxuICogRGVzdHJveXMgdGhlIGNsaWVudCwgZW1pdHMgJ2VuZCdcbiAqL1xuU01UUENvbm5lY3Rpb24ucHJvdG90eXBlLl9kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLl9kZXN0cm95ZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9kZXN0cm95ZWQgPSB0cnVlO1xuICAgIHRoaXMuZW1pdCgnZW5kJyk7XG59O1xuXG4vKipcbiAqIFVwZ3JhZGVzIHRoZSBjb25uZWN0aW9uIHRvIFRMU1xuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrIGZ1bmN0aW9uIHRvIHJ1biB3aGVuIHRoZSBjb25uZWN0aW9uXG4gKiAgICAgICAgaGFzIGJlZW4gc2VjdXJlZFxuICovXG5TTVRQQ29ubmVjdGlvbi5wcm90b3R5cGUuX3VwZ3JhZGVDb25uZWN0aW9uID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgLy8gZG8gbm90IHJlbW92ZSBhbGwgbGlzdGVuZXJzIG9yIGl0IGJyZWFrcyBub2RlIHYwLjEwIGFzIHRoZXJlJ3NcbiAgICAvLyBhcHBhcmVudGx5IGEgJ2ZpbmlzaCcgZXZlbnQgc2V0IHRoYXQgd291bGQgYmUgY2xlYXJlZCBhcyB3ZWxsXG5cbiAgICAvLyB3ZSBjYW4gc2FmZWx5IGtlZXAgJ2Vycm9yJywgJ2VuZCcsICdjbG9zZScgZXRjLiBldmVudHNcbiAgICB0aGlzLl9zb2NrZXQucmVtb3ZlQWxsTGlzdGVuZXJzKCdkYXRhJyk7IC8vIGluY29taW5nIGRhdGEgaXMgZ29pbmcgdG8gYmUgZ2liYmVyaXNoIGZyb20gdGhpcyBwb2ludCBvbndhcmRzXG4gICAgdGhpcy5fc29ja2V0LnJlbW92ZUFsbExpc3RlbmVycygndGltZW91dCcpOyAvLyB0aW1lb3V0IHdpbGwgYmUgcmUtc2V0IGZvciB0aGUgbmV3IHNvY2tldCBvYmplY3RcblxuICAgIHZhciBzb2NrZXRQbGFpbiA9IHRoaXMuX3NvY2tldDtcbiAgICB2YXIgb3B0cyA9IHtcbiAgICAgICAgc29ja2V0OiB0aGlzLl9zb2NrZXQsXG4gICAgICAgIGhvc3Q6IHRoaXMuaG9zdFxuICAgIH07XG5cbiAgICBPYmplY3Qua2V5cyh0aGlzLm9wdGlvbnMudGxzIHx8IHt9KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgb3B0c1trZXldID0gdGhpcy5vcHRpb25zLnRsc1trZXldO1xuICAgIH0uYmluZCh0aGlzKSk7XG5cbiAgICB0aGlzLl9zb2NrZXQgPSB0bHMuY29ubmVjdChvcHRzLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuc2VjdXJlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fc29ja2V0Lm9uKCdkYXRhJywgdGhpcy5fb25EYXRhLmJpbmQodGhpcykpO1xuXG4gICAgICAgIHNvY2tldFBsYWluLnJlbW92ZUFsbExpc3RlbmVycygnY2xvc2UnKTtcbiAgICAgICAgc29ja2V0UGxhaW4ucmVtb3ZlQWxsTGlzdGVuZXJzKCdlbmQnKTtcblxuICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgdHJ1ZSk7XG4gICAgfS5iaW5kKHRoaXMpKTtcblxuICAgIHRoaXMuX3NvY2tldC5vbignZXJyb3InLCB0aGlzLl9vbkVycm9yLmJpbmQodGhpcykpO1xuICAgIHRoaXMuX3NvY2tldC5vbmNlKCdjbG9zZScsIHRoaXMuX29uQ2xvc2UuYmluZCh0aGlzKSk7XG4gICAgdGhpcy5fc29ja2V0Lm9uY2UoJ2VuZCcsIHRoaXMuX29uRW5kLmJpbmQodGhpcykpO1xuXG4gICAgdGhpcy5fc29ja2V0LnNldFRpbWVvdXQodGhpcy5vcHRpb25zLnNvY2tldFRpbWVvdXQgfHwgU09DS0VUX1RJTUVPVVQpOyAvLyAxMCBtaW4uXG4gICAgdGhpcy5fc29ja2V0Lm9uKCd0aW1lb3V0JywgdGhpcy5fb25UaW1lb3V0LmJpbmQodGhpcykpO1xuXG4gICAgLy8gcmVzdW1lIGluIGNhc2UgdGhlIHNvY2tldCB3YXMgcGF1c2VkXG4gICAgc29ja2V0UGxhaW4ucmVzdW1lKCk7XG59O1xuXG4vKipcbiAqIFByb2Nlc3NlcyBxdWV1ZWQgcmVzcG9uc2VzIGZyb20gdGhlIHNlcnZlclxuICpcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gZm9yY2UgSWYgdHJ1ZSwgaWdub3JlcyBfcHJvY2Vzc2luZyBmbGFnXG4gKi9cblNNVFBDb25uZWN0aW9uLnByb3RvdHlwZS5fcHJvY2Vzc1Jlc3BvbnNlID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICghdGhpcy5fcmVzcG9uc2VRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBzdHIgPSAodGhpcy5fcmVzcG9uc2VRdWV1ZS5zaGlmdCgpIHx8ICcnKS50b1N0cmluZygpO1xuXG4gICAgaWYgKC9eXFxkK1xcLS8udGVzdChzdHIuc3BsaXQoJ1xcbicpLnBvcCgpKSkge1xuICAgICAgICAvLyBrZWVwIHdhaXRpbmcgZm9yIHRoZSBmaW5hbCBwYXJ0IG9mIG11bHRpbGluZSByZXNwb25zZVxuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5kZWJ1Zykge1xuICAgICAgICB0aGlzLmxvZ2dlci5kZWJ1ZygnWyVzXSBTOiAlcycsIHRoaXMuaWQsIHN0ci5yZXBsYWNlKC9cXHI/XFxuJC8sICcnKSk7XG4gICAgfVxuXG4gICAgaWYgKCFzdHIudHJpbSgpKSB7IC8vIHNraXAgdW5leHBlY3RlZCBlbXB0eSBsaW5lc1xuICAgICAgICBzZXRJbW1lZGlhdGUodGhpcy5fcHJvY2Vzc1Jlc3BvbnNlLmJpbmQodGhpcywgdHJ1ZSkpO1xuICAgIH1cblxuICAgIHZhciBhY3Rpb24gPSB0aGlzLl9yZXNwb25zZUFjdGlvbnMuc2hpZnQoKTtcblxuICAgIGlmICh0eXBlb2YgYWN0aW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGFjdGlvbi5jYWxsKHRoaXMsIHN0cik7XG4gICAgICAgIHNldEltbWVkaWF0ZSh0aGlzLl9wcm9jZXNzUmVzcG9uc2UuYmluZCh0aGlzLCB0cnVlKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX29uRXJyb3IobmV3IEVycm9yKCdVbmV4cGVjdGVkIFJlc3BvbnNlJyksICdFUFJPVE9DT0wnLCBzdHIsICdDT05OJyk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBTZW5kIGEgY29tbWFuZCB0byB0aGUgc2VydmVyLCBhcHBlbmQgXFxyXFxuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0ciBTdHJpbmcgdG8gYmUgc2VudCB0byB0aGUgc2VydmVyXG4gKi9cblNNVFBDb25uZWN0aW9uLnByb3RvdHlwZS5fc2VuZENvbW1hbmQgPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgaWYgKHRoaXMuX2Rlc3Ryb3llZCkge1xuICAgICAgICAvLyBDb25uZWN0aW9uIGFscmVhZHkgY2xvc2VkLCBjYW4ndCBzZW5kIGFueSBtb3JlIGRhdGFcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9zb2NrZXQuZGVzdHJveWVkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsb3NlKCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5kZWJ1Zykge1xuICAgICAgICB0aGlzLmxvZ2dlci5kZWJ1ZygnWyVzXSBDOiAlcycsIHRoaXMuaWQsIChzdHIgfHwgJycpLnRvU3RyaW5nKCkucmVwbGFjZSgvXFxyP1xcbiQvLCAnJykpO1xuICAgIH1cblxuICAgIHRoaXMuX3NvY2tldC53cml0ZShuZXcgQnVmZmVyKHN0ciArICdcXHJcXG4nLCAndXRmLTgnKSk7XG59O1xuXG4vKipcbiAqIEluaXRpYXRlcyBhIG5ldyBtZXNzYWdlIGJ5IHN1Ym1pdHRpbmcgZW52ZWxvcGUgZGF0YSwgc3RhcnRpbmcgd2l0aFxuICogTUFJTCBGUk9NOiBjb21tYW5kXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGVudmVsb3BlIEVudmVsb3BlIG9iamVjdCBpbiB0aGUgZm9ybSBvZlxuICogICAgICAgIHtmcm9tOicuLi4nLCB0bzpbJy4uLiddfVxuICogICAgICAgIG9yXG4gKiAgICAgICAge2Zyb206e2FkZHJlc3M6Jy4uLicsbmFtZTonLi4uJ30sIHRvOlthZGRyZXNzOicuLi4nLG5hbWU6Jy4uLiddfVxuICovXG5TTVRQQ29ubmVjdGlvbi5wcm90b3R5cGUuX3NldEVudmVsb3BlID0gZnVuY3Rpb24gKGVudmVsb3BlLCBjYWxsYmFjaykge1xuICAgIHZhciBhcmdzID0gW107XG4gICAgdmFyIHVzZVNtdHBVdGY4ID0gZmFsc2U7XG5cbiAgICB0aGlzLl9lbnZlbG9wZSA9IGVudmVsb3BlIHx8IHt9O1xuICAgIHRoaXMuX2VudmVsb3BlLmZyb20gPSAodGhpcy5fZW52ZWxvcGUuZnJvbSAmJiB0aGlzLl9lbnZlbG9wZS5mcm9tLmFkZHJlc3MgfHwgdGhpcy5fZW52ZWxvcGUuZnJvbSB8fCAnJykudG9TdHJpbmcoKS50cmltKCk7XG5cbiAgICB0aGlzLl9lbnZlbG9wZS50byA9IFtdLmNvbmNhdCh0aGlzLl9lbnZlbG9wZS50byB8fCBbXSkubWFwKGZ1bmN0aW9uICh0bykge1xuICAgICAgICByZXR1cm4gKHRvICYmIHRvLmFkZHJlc3MgfHwgdG8gfHwgJycpLnRvU3RyaW5nKCkudHJpbSgpO1xuICAgIH0pO1xuXG4gICAgaWYgKCF0aGlzLl9lbnZlbG9wZS50by5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKHRoaXMuX2Zvcm1hdEVycm9yKCdObyByZWNpcGllbnRzIGRlZmluZWQnLCAnRUVOVkVMT1BFJywgZmFsc2UsICdBUEknKSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2VudmVsb3BlLmZyb20gJiYgL1tcXHJcXG48Pl0vLnRlc3QodGhpcy5fZW52ZWxvcGUuZnJvbSkpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKHRoaXMuX2Zvcm1hdEVycm9yKCdJbnZhbGlkIHNlbmRlciAnICsgSlNPTi5zdHJpbmdpZnkodGhpcy5fZW52ZWxvcGUuZnJvbSksICdFRU5WRUxPUEUnLCBmYWxzZSwgJ0FQSScpKTtcbiAgICB9XG5cbiAgICAvLyBjaGVjayBpZiB0aGUgc2VuZGVyIGFkZHJlc3MgdXNlcyBvbmx5IEFTQ0lJIGNoYXJhY3RlcnMsXG4gICAgLy8gb3RoZXJ3aXNlIHJlcXVpcmUgdXNhZ2Ugb2YgU01UUFVURjggZXh0ZW5zaW9uXG4gICAgaWYgKC9bXFx4ODAtXFx1RkZGRl0vLnRlc3QodGhpcy5fZW52ZWxvcGUuZnJvbSkpIHtcbiAgICAgICAgdXNlU210cFV0ZjggPSB0cnVlO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLl9lbnZlbG9wZS50by5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBpZiAoIXRoaXMuX2VudmVsb3BlLnRvW2ldIHx8IC9bXFxyXFxuPD5dLy50ZXN0KHRoaXMuX2VudmVsb3BlLnRvW2ldKSkge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKHRoaXMuX2Zvcm1hdEVycm9yKCdJbnZhbGlkIHJlY2lwaWVudCAnICsgSlNPTi5zdHJpbmdpZnkodGhpcy5fZW52ZWxvcGUudG9baV0pLCAnRUVOVkVMT1BFJywgZmFsc2UsICdBUEknKSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjaGVjayBpZiB0aGUgcmVjaXBpZW50cyBhZGRyZXNzZXMgdXNlIG9ubHkgQVNDSUkgY2hhcmFjdGVycyxcbiAgICAgICAgLy8gb3RoZXJ3aXNlIHJlcXVpcmUgdXNhZ2Ugb2YgU01UUFVURjggZXh0ZW5zaW9uXG4gICAgICAgIGlmICgvW1xceDgwLVxcdUZGRkZdLy50ZXN0KHRoaXMuX2VudmVsb3BlLnRvW2ldKSkge1xuICAgICAgICAgICAgdXNlU210cFV0ZjggPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gY2xvbmUgdGhlIHJlY2lwaWVudHMgYXJyYXkgZm9yIGxhdHRlciBtYW5pcHVsYXRpb25cbiAgICB0aGlzLl9lbnZlbG9wZS5yY3B0UXVldWUgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHRoaXMuX2VudmVsb3BlLnRvIHx8IFtdKSk7XG4gICAgdGhpcy5fZW52ZWxvcGUucmVqZWN0ZWQgPSBbXTtcbiAgICB0aGlzLl9lbnZlbG9wZS5yZWplY3RlZEVycm9ycyA9IFtdO1xuICAgIHRoaXMuX2VudmVsb3BlLmFjY2VwdGVkID0gW107XG5cbiAgICBpZiAodGhpcy5fZW52ZWxvcGUuZHNuKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLl9lbnZlbG9wZS5kc24gPSB0aGlzLl9zZXREc25FbnZlbG9wZSh0aGlzLl9lbnZlbG9wZS5kc24pO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayh0aGlzLl9mb3JtYXRFcnJvcignSW52YWxpZCBkc24gJyArIGVyci5tZXNzYWdlLCAnRUVOVkVMT1BFJywgZmFsc2UsICdBUEknKSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLl9yZXNwb25zZUFjdGlvbnMucHVzaChmdW5jdGlvbiAoc3RyKSB7XG4gICAgICAgIHRoaXMuX2FjdGlvbk1BSUwoc3RyLCBjYWxsYmFjayk7XG4gICAgfS5iaW5kKHRoaXMpKTtcblxuICAgIC8vIElmIHRoZSBzZXJ2ZXIgc3VwcG9ydHMgU01UUFVURjggYW5kIHRoZSBlbnZlbG9wZSBpbmNsdWRlcyBhbiBpbnRlcm5hdGlvbmFsaXplZFxuICAgIC8vIGVtYWlsIGFkZHJlc3MgdGhlbiBhcHBlbmQgU01UUFVURjgga2V5d29yZCB0byB0aGUgTUFJTCBGUk9NIGNvbW1hbmRcbiAgICBpZiAodXNlU210cFV0ZjggJiYgdGhpcy5fc3VwcG9ydGVkRXh0ZW5zaW9ucy5pbmRleE9mKCdTTVRQVVRGOCcpID49IDApIHtcbiAgICAgICAgYXJncy5wdXNoKCdTTVRQVVRGOCcpO1xuICAgICAgICB0aGlzLl91c2luZ1NtdHBVdGY4ID0gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgc2VydmVyIHN1cHBvcnRzIDhCSVRNSU1FIGFuZCB0aGUgbWVzc2FnZSBtaWdodCBjb250YWluIG5vbi1hc2NpaSBieXRlc1xuICAgIC8vIHRoZW4gYXBwZW5kIHRoZSA4QklUTUlNRSBrZXl3b3JkIHRvIHRoZSBNQUlMIEZST00gY29tbWFuZFxuICAgIGlmICh0aGlzLl9lbnZlbG9wZS51c2U4Qml0TWltZSAmJiB0aGlzLl9zdXBwb3J0ZWRFeHRlbnNpb25zLmluZGV4T2YoJzhCSVRNSU1FJykgPj0gMCkge1xuICAgICAgICBhcmdzLnB1c2goJ0JPRFk9OEJJVE1JTUUnKTtcbiAgICAgICAgdGhpcy5fdXNpbmc4Qml0TWltZSA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2VudmVsb3BlLnNpemUgJiYgdGhpcy5fc3VwcG9ydGVkRXh0ZW5zaW9ucy5pbmRleE9mKCdTSVpFJykgPj0gMCkge1xuICAgICAgICBhcmdzLnB1c2goJ1NJWkU9JyArIHRoaXMuX2VudmVsb3BlLnNpemUpO1xuICAgIH1cblxuICAgIC8vIElmIHRoZSBzZXJ2ZXIgc3VwcG9ydHMgRFNOIGFuZCB0aGUgZW52ZWxvcGUgaW5jbHVkZXMgYW4gRFNOIHByb3BcbiAgICAvLyB0aGVuIGFwcGVuZCBEU04gcGFyYW1zIHRvIHRoZSBNQUlMIEZST00gY29tbWFuZFxuICAgIGlmICh0aGlzLl9lbnZlbG9wZS5kc24gJiYgdGhpcy5fc3VwcG9ydGVkRXh0ZW5zaW9ucy5pbmRleE9mKCdEU04nKSA+PSAwKSB7XG4gICAgICAgIGlmICh0aGlzLl9lbnZlbG9wZS5kc24ucmV0KSB7XG4gICAgICAgICAgICBhcmdzLnB1c2goJ1JFVD0nICsgdGhpcy5fZW52ZWxvcGUuZHNuLnJldCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2VudmVsb3BlLmRzbi5lbnZpZCkge1xuICAgICAgICAgICAgYXJncy5wdXNoKCdFTlZJRD0nICsgdGhpcy5fZW52ZWxvcGUuZHNuLmVudmlkKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuX3NlbmRDb21tYW5kKCdNQUlMIEZST006PCcgKyAodGhpcy5fZW52ZWxvcGUuZnJvbSkgKyAnPicgKyAoYXJncy5sZW5ndGggPyAnICcgKyBhcmdzLmpvaW4oJyAnKSA6ICcnKSk7XG59O1xuXG5TTVRQQ29ubmVjdGlvbi5wcm90b3R5cGUuX3NldERzbkVudmVsb3BlID0gZnVuY3Rpb24gKHBhcmFtcykge1xuICAgIHZhciByZXQgPSBwYXJhbXMucmV0ID8gcGFyYW1zLnJldC50b1N0cmluZygpLnRvVXBwZXJDYXNlKCkgOiBudWxsO1xuICAgIGlmIChyZXQgJiYgWydGVUxMJywgJ0hEUlMnXS5pbmRleE9mKHJldCkgPCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncmV0OiAnICsgSlNPTi5zdHJpbmdpZnkocmV0KSk7XG4gICAgfVxuICAgIHZhciBlbnZpZCA9IHBhcmFtcy5lbnZpZCA/IHBhcmFtcy5lbnZpZC50b1N0cmluZygpIDogbnVsbDtcbiAgICB2YXIgbm90aWZ5ID0gcGFyYW1zLm5vdGlmeSA/IHBhcmFtcy5ub3RpZnkgOiBudWxsO1xuICAgIGlmIChub3RpZnkpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBub3RpZnkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBub3RpZnkgPSBub3RpZnkuc3BsaXQoJywnKTtcbiAgICAgICAgfVxuICAgICAgICBub3RpZnkgPSBub3RpZnkubWFwKGZ1bmN0aW9uIChuKSB7XG4gICAgICAgICAgICByZXR1cm4gbi50cmltKCkudG9VcHBlckNhc2UoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciB2YWxpZE5vdGlmeSA9IFsnTkVWRVInLCAnU1VDQ0VTUycsICdGQUlMVVJFJywgJ0RFTEFZJ107XG4gICAgICAgIHZhciBpbnZhbGlOb3RpZnkgPSBub3RpZnkuZmlsdGVyKGZ1bmN0aW9uIChuKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsaWROb3RpZnkuaW5kZXhPZihuKSA9PT0gLTE7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoaW52YWxpTm90aWZ5Lmxlbmd0aCB8fCAobm90aWZ5Lmxlbmd0aCA+IDEgJiYgbm90aWZ5LmluZGV4T2YoJ05FVkVSJykgPj0gMCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbm90aWZ5OiAnICsgSlNPTi5zdHJpbmdpZnkobm90aWZ5LmpvaW4oJywnKSkpO1xuICAgICAgICB9XG4gICAgICAgIG5vdGlmeSA9IG5vdGlmeS5qb2luKCcsJyk7XG4gICAgfVxuICAgIHZhciBvcmNwdCA9IHBhcmFtcy5vcmNwdCA/IHBhcmFtcy5vcmNwdC50b1N0cmluZygpIDogbnVsbDtcbiAgICByZXR1cm4ge1xuICAgICAgICByZXQ6IHJldCxcbiAgICAgICAgZW52aWQ6IGVudmlkLFxuICAgICAgICBub3RpZnk6IG5vdGlmeSxcbiAgICAgICAgb3JjcHQ6IG9yY3B0XG4gICAgfTtcbn07XG5cblNNVFBDb25uZWN0aW9uLnByb3RvdHlwZS5fZ2V0RHNuUmNwdFRvQXJncyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYXJncyA9IFtdO1xuICAgIC8vIElmIHRoZSBzZXJ2ZXIgc3VwcG9ydHMgRFNOIGFuZCB0aGUgZW52ZWxvcGUgaW5jbHVkZXMgYW4gRFNOIHByb3BcbiAgICAvLyB0aGVuIGFwcGVuZCBEU04gcGFyYW1zIHRvIHRoZSBSQ1BUIFRPIGNvbW1hbmRcbiAgICBpZiAodGhpcy5fZW52ZWxvcGUuZHNuICYmIHRoaXMuX3N1cHBvcnRlZEV4dGVuc2lvbnMuaW5kZXhPZignRFNOJykgPj0gMCkge1xuICAgICAgICBpZiAodGhpcy5fZW52ZWxvcGUuZHNuLm5vdGlmeSkge1xuICAgICAgICAgICAgYXJncy5wdXNoKCdOT1RJRlk9JyArIHRoaXMuX2VudmVsb3BlLmRzbi5ub3RpZnkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9lbnZlbG9wZS5kc24ub3JjcHQpIHtcbiAgICAgICAgICAgIGFyZ3MucHVzaCgnT1JDUFQ9JyArIHRoaXMuX2VudmVsb3BlLmRzbi5vcmNwdCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIChhcmdzLmxlbmd0aCA/ICcgJyArIGFyZ3Muam9pbignICcpIDogJycpO1xufTtcblxuU01UUENvbm5lY3Rpb24ucHJvdG90eXBlLl9jcmVhdGVTZW5kU3RyZWFtID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgdmFyIGRhdGFTdHJlYW0gPSBuZXcgRGF0YVN0cmVhbSgpO1xuICAgIHZhciBsb2dTdHJlYW07XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLmxtdHApIHtcbiAgICAgICAgdGhpcy5fZW52ZWxvcGUuYWNjZXB0ZWQuZm9yRWFjaChmdW5jdGlvbiAocmVjaXBpZW50LCBpKSB7XG4gICAgICAgICAgICB2YXIgZmluYWwgPSBpID09PSB0aGlzLl9lbnZlbG9wZS5hY2NlcHRlZC5sZW5ndGggLSAxO1xuICAgICAgICAgICAgdGhpcy5fcmVzcG9uc2VBY3Rpb25zLnB1c2goZnVuY3Rpb24gKHN0cikge1xuICAgICAgICAgICAgICAgIHRoaXMuX2FjdGlvbkxNVFBTdHJlYW0ocmVjaXBpZW50LCBmaW5hbCwgc3RyLCBjYWxsYmFjayk7XG4gICAgICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3Jlc3BvbnNlQWN0aW9ucy5wdXNoKGZ1bmN0aW9uIChzdHIpIHtcbiAgICAgICAgICAgIHRoaXMuX2FjdGlvblNNVFBTdHJlYW0oc3RyLCBjYWxsYmFjayk7XG4gICAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgfVxuXG4gICAgZGF0YVN0cmVhbS5waXBlKHRoaXMuX3NvY2tldCwge1xuICAgICAgICBlbmQ6IGZhbHNlXG4gICAgfSk7XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLmRlYnVnKSB7XG4gICAgICAgIGxvZ1N0cmVhbSA9IG5ldyBQYXNzVGhyb3VnaCgpO1xuICAgICAgICBsb2dTdHJlYW0ub24oJ3JlYWRhYmxlJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGNodW5rO1xuICAgICAgICAgICAgd2hpbGUgKChjaHVuayA9IGxvZ1N0cmVhbS5yZWFkKCkpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIuZGVidWcoJ1slc10gQzogJXMnLCB0aGlzLmlkLCBjaHVuay50b1N0cmluZygnYmluYXJ5JykucmVwbGFjZSgvXFxyP1xcbiQvLCAnJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgICAgICBkYXRhU3RyZWFtLnBpcGUobG9nU3RyZWFtKTtcbiAgICB9XG5cbiAgICBkYXRhU3RyZWFtLm9uY2UoJ2VuZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5sb2dnZXIuaW5mbygnWyVzXSBDOiA8JXMgYnl0ZXMgZW5jb2RlZCBtaW1lIG1lc3NhZ2UgKHNvdXJjZSBzaXplICVzIGJ5dGVzKT4nLCB0aGlzLmlkLCBkYXRhU3RyZWFtLm91dEJ5dGVDb3VudCwgZGF0YVN0cmVhbS5pbkJ5dGVDb3VudCk7XG4gICAgfS5iaW5kKHRoaXMpKTtcblxuICAgIHJldHVybiBkYXRhU3RyZWFtO1xufTtcblxuLyoqIEFDVElPTlMgKiovXG5cbi8qKlxuICogV2lsbCBiZSBydW4gYWZ0ZXIgdGhlIGNvbm5lY3Rpb24gaXMgY3JlYXRlZCBhbmQgdGhlIHNlcnZlciBzZW5kc1xuICogYSBncmVldGluZy4gSWYgdGhlIGluY29taW5nIG1lc3NhZ2Ugc3RhcnRzIHdpdGggMjIwIGluaXRpYXRlXG4gKiBTTVRQIHNlc3Npb24gYnkgc2VuZGluZyBFSExPIGNvbW1hbmRcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyIE1lc3NhZ2UgZnJvbSB0aGUgc2VydmVyXG4gKi9cblNNVFBDb25uZWN0aW9uLnByb3RvdHlwZS5fYWN0aW9uR3JlZXRpbmcgPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMuX2dyZWV0aW5nVGltZW91dCk7XG5cbiAgICBpZiAoc3RyLnN1YnN0cigwLCAzKSAhPT0gJzIyMCcpIHtcbiAgICAgICAgdGhpcy5fb25FcnJvcihuZXcgRXJyb3IoJ0ludmFsaWQgZ3JlZXRpbmcgZnJvbSBzZXJ2ZXI6XFxuJyArIHN0ciksICdFUFJPVE9DT0wnLCBzdHIsICdDT05OJyk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLmxtdHApIHtcbiAgICAgICAgdGhpcy5fcmVzcG9uc2VBY3Rpb25zLnB1c2godGhpcy5fYWN0aW9uTEhMTyk7XG4gICAgICAgIHRoaXMuX3NlbmRDb21tYW5kKCdMSExPICcgKyB0aGlzLm5hbWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3Jlc3BvbnNlQWN0aW9ucy5wdXNoKHRoaXMuX2FjdGlvbkVITE8pO1xuICAgICAgICB0aGlzLl9zZW5kQ29tbWFuZCgnRUhMTyAnICsgdGhpcy5uYW1lKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIEhhbmRsZXMgc2VydmVyIHJlc3BvbnNlIGZvciBMSExPIGNvbW1hbmQuIElmIGl0IHlpZWxkZWQgaW5cbiAqIGVycm9yLCBlbWl0ICdlcnJvcicsIG90aGVyd2lzZSB0cmVhdCB0aGlzIGFzIGFuIEVITE8gcmVzcG9uc2VcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyIE1lc3NhZ2UgZnJvbSB0aGUgc2VydmVyXG4gKi9cblNNVFBDb25uZWN0aW9uLnByb3RvdHlwZS5fYWN0aW9uTEhMTyA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICBpZiAoc3RyLmNoYXJBdCgwKSAhPT0gJzInKSB7XG4gICAgICAgIHRoaXMuX29uRXJyb3IobmV3IEVycm9yKCdJbnZhbGlkIHJlc3BvbnNlIGZvciBMSExPOlxcbicgKyBzdHIpLCAnRVBST1RPQ09MJywgc3RyLCAnTEhMTycpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5fYWN0aW9uRUhMTyhzdHIpO1xufTtcblxuLyoqXG4gKiBIYW5kbGVzIHNlcnZlciByZXNwb25zZSBmb3IgRUhMTyBjb21tYW5kLiBJZiBpdCB5aWVsZGVkIGluXG4gKiBlcnJvciwgdHJ5IEhFTE8gaW5zdGVhZCwgb3RoZXJ3aXNlIGluaXRpYXRlIFRMUyBuZWdvdGlhdGlvblxuICogaWYgU1RBUlRUTFMgaXMgc3VwcG9ydGVkIGJ5IHRoZSBzZXJ2ZXIgb3IgbW92ZSBpbnRvIHRoZVxuICogYXV0aGVudGljYXRpb24gcGhhc2UuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0ciBNZXNzYWdlIGZyb20gdGhlIHNlcnZlclxuICovXG5TTVRQQ29ubmVjdGlvbi5wcm90b3R5cGUuX2FjdGlvbkVITE8gPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgdmFyIG1hdGNoO1xuXG4gICAgaWYgKHN0ci5zdWJzdHIoMCwgMykgPT09ICc0MjEnKSB7XG4gICAgICAgIHRoaXMuX29uRXJyb3IobmV3IEVycm9yKCdTZXJ2ZXIgdGVybWluYXRlcyBjb25uZWN0aW9uOlxcbicgKyBzdHIpLCAnRUNPTk5FQ1RJT04nLCBzdHIsICdFSExPJyk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoc3RyLmNoYXJBdCgwKSAhPT0gJzInKSB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMucmVxdWlyZVRMUykge1xuICAgICAgICAgICAgdGhpcy5fb25FcnJvcihuZXcgRXJyb3IoJ0VITE8gZmFpbGVkIGJ1dCBIRUxPIGRvZXMgbm90IHN1cHBvcnQgcmVxdWlyZWQgU1RBUlRUTFM6XFxuJyArIHN0ciksICdFQ09OTkVDVElPTicsIHN0ciwgJ0VITE8nKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRyeSBIRUxPIGluc3RlYWRcbiAgICAgICAgdGhpcy5fcmVzcG9uc2VBY3Rpb25zLnB1c2godGhpcy5fYWN0aW9uSEVMTyk7XG4gICAgICAgIHRoaXMuX3NlbmRDb21tYW5kKCdIRUxPICcgKyB0aGlzLm5hbWUpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gRGV0ZWN0IGlmIHRoZSBzZXJ2ZXIgc3VwcG9ydHMgU1RBUlRUTFNcbiAgICBpZiAoIXRoaXMuc2VjdXJlICYmICF0aGlzLm9wdGlvbnMuaWdub3JlVExTICYmICgvWyBcXC1dU1RBUlRUTFNcXGIvbWkudGVzdChzdHIpIHx8IHRoaXMub3B0aW9ucy5yZXF1aXJlVExTKSkge1xuICAgICAgICB0aGlzLl9zZW5kQ29tbWFuZCgnU1RBUlRUTFMnKTtcbiAgICAgICAgdGhpcy5fcmVzcG9uc2VBY3Rpb25zLnB1c2godGhpcy5fYWN0aW9uU1RBUlRUTFMpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gRGV0ZWN0IGlmIHRoZSBzZXJ2ZXIgc3VwcG9ydHMgU01UUFVURjhcbiAgICBpZiAoL1sgXFwtXVNNVFBVVEY4XFxiL21pLnRlc3Qoc3RyKSkge1xuICAgICAgICB0aGlzLl9zdXBwb3J0ZWRFeHRlbnNpb25zLnB1c2goJ1NNVFBVVEY4Jyk7XG4gICAgfVxuXG4gICAgLy8gRGV0ZWN0IGlmIHRoZSBzZXJ2ZXIgc3VwcG9ydHMgRFNOXG4gICAgaWYgKC9bIFxcLV1EU05cXGIvbWkudGVzdChzdHIpKSB7XG4gICAgICAgIHRoaXMuX3N1cHBvcnRlZEV4dGVuc2lvbnMucHVzaCgnRFNOJyk7XG4gICAgfVxuXG4gICAgLy8gRGV0ZWN0IGlmIHRoZSBzZXJ2ZXIgc3VwcG9ydHMgOEJJVE1JTUVcbiAgICBpZiAoL1sgXFwtXThCSVRNSU1FXFxiL21pLnRlc3Qoc3RyKSkge1xuICAgICAgICB0aGlzLl9zdXBwb3J0ZWRFeHRlbnNpb25zLnB1c2goJzhCSVRNSU1FJyk7XG4gICAgfVxuXG4gICAgLy8gRGV0ZWN0IGlmIHRoZSBzZXJ2ZXIgc3VwcG9ydHMgUElQRUxJTklOR1xuICAgIGlmICgvWyBcXC1dUElQRUxJTklOR1xcYi9taS50ZXN0KHN0cikpIHtcbiAgICAgICAgdGhpcy5fc3VwcG9ydGVkRXh0ZW5zaW9ucy5wdXNoKCdQSVBFTElOSU5HJyk7XG4gICAgfVxuXG4gICAgLy8gRGV0ZWN0IGlmIHRoZSBzZXJ2ZXIgc3VwcG9ydHMgUExBSU4gYXV0aFxuICAgIGlmICgvQVVUSCg/OihcXHMrfD0pW15cXG5dKlxccyt8XFxzK3w9KVBMQUlOL2kudGVzdChzdHIpKSB7XG4gICAgICAgIHRoaXMuX3N1cHBvcnRlZEF1dGgucHVzaCgnUExBSU4nKTtcbiAgICB9XG5cbiAgICAvLyBEZXRlY3QgaWYgdGhlIHNlcnZlciBzdXBwb3J0cyBMT0dJTiBhdXRoXG4gICAgaWYgKC9BVVRIKD86KFxccyt8PSlbXlxcbl0qXFxzK3xcXHMrfD0pTE9HSU4vaS50ZXN0KHN0cikpIHtcbiAgICAgICAgdGhpcy5fc3VwcG9ydGVkQXV0aC5wdXNoKCdMT0dJTicpO1xuICAgIH1cblxuICAgIC8vIERldGVjdCBpZiB0aGUgc2VydmVyIHN1cHBvcnRzIENSQU0tTUQ1IGF1dGhcbiAgICBpZiAoL0FVVEgoPzooXFxzK3w9KVteXFxuXSpcXHMrfFxccyt8PSlDUkFNLU1ENS9pLnRlc3Qoc3RyKSkge1xuICAgICAgICB0aGlzLl9zdXBwb3J0ZWRBdXRoLnB1c2goJ0NSQU0tTUQ1Jyk7XG4gICAgfVxuXG4gICAgLy8gRGV0ZWN0IGlmIHRoZSBzZXJ2ZXIgc3VwcG9ydHMgWE9BVVRIMiBhdXRoXG4gICAgaWYgKC9BVVRIKD86KFxccyt8PSlbXlxcbl0qXFxzK3xcXHMrfD0pWE9BVVRIMi9pLnRlc3Qoc3RyKSkge1xuICAgICAgICB0aGlzLl9zdXBwb3J0ZWRBdXRoLnB1c2goJ1hPQVVUSDInKTtcbiAgICB9XG5cbiAgICAvLyBEZXRlY3QgaWYgdGhlIHNlcnZlciBzdXBwb3J0cyBTSVpFIGV4dGVuc2lvbnMgKGFuZCB0aGUgbWF4IGFsbG93ZWQgc2l6ZSlcbiAgICBpZiAoKG1hdGNoID0gc3RyLm1hdGNoKC9bIFxcLV1TSVpFKD86XFxzKyhcXGQrKSk/L21pKSkpIHtcbiAgICAgICAgdGhpcy5fc3VwcG9ydGVkRXh0ZW5zaW9ucy5wdXNoKCdTSVpFJyk7XG4gICAgICAgIHRoaXMuX21heEFsbG93ZWRTaXplID0gTnVtYmVyKG1hdGNoWzFdKSB8fCAwO1xuICAgIH1cblxuICAgIHRoaXMuZW1pdCgnY29ubmVjdCcpO1xufTtcblxuLyoqXG4gKiBIYW5kbGVzIHNlcnZlciByZXNwb25zZSBmb3IgSEVMTyBjb21tYW5kLiBJZiBpdCB5aWVsZGVkIGluXG4gKiBlcnJvciwgZW1pdCAnZXJyb3InLCBvdGhlcndpc2UgbW92ZSBpbnRvIHRoZSBhdXRoZW50aWNhdGlvbiBwaGFzZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyIE1lc3NhZ2UgZnJvbSB0aGUgc2VydmVyXG4gKi9cblNNVFBDb25uZWN0aW9uLnByb3RvdHlwZS5fYWN0aW9uSEVMTyA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICBpZiAoc3RyLmNoYXJBdCgwKSAhPT0gJzInKSB7XG4gICAgICAgIHRoaXMuX29uRXJyb3IobmV3IEVycm9yKCdJbnZhbGlkIHJlc3BvbnNlIGZvciBFSExPL0hFTE86XFxuJyArIHN0ciksICdFUFJPVE9DT0wnLCBzdHIsICdIRUxPJyk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmVtaXQoJ2Nvbm5lY3QnKTtcbn07XG5cbi8qKlxuICogSGFuZGxlcyBzZXJ2ZXIgcmVzcG9uc2UgZm9yIFNUQVJUVExTIGNvbW1hbmQuIElmIHRoZXJlJ3MgYW4gZXJyb3JcbiAqIHRyeSBIRUxPIGluc3RlYWQsIG90aGVyd2lzZSBpbml0aWF0ZSBUTFMgdXBncmFkZS4gSWYgdGhlIHVwZ3JhZGVcbiAqIHN1Y2NlZWRlcyByZXN0YXJ0IHRoZSBFSExPXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0ciBNZXNzYWdlIGZyb20gdGhlIHNlcnZlclxuICovXG5TTVRQQ29ubmVjdGlvbi5wcm90b3R5cGUuX2FjdGlvblNUQVJUVExTID0gZnVuY3Rpb24gKHN0cikge1xuICAgIGlmIChzdHIuY2hhckF0KDApICE9PSAnMicpIHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5vcHBvcnR1bmlzdGljVExTKSB7XG4gICAgICAgICAgICB0aGlzLmxvZ2dlci5pbmZvKCdbJXNdIEZhaWxlZCBTVEFSVFRMUyB1cGdyYWRlLCBjb250aW51aW5nIHVuZW5jcnlwdGVkJywgdGhpcy5pZCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lbWl0KCdjb25uZWN0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fb25FcnJvcihuZXcgRXJyb3IoJ0Vycm9yIHVwZ3JhZGluZyBjb25uZWN0aW9uIHdpdGggU1RBUlRUTFMnKSwgJ0VUTFMnLCBzdHIsICdTVEFSVFRMUycpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5fdXBncmFkZUNvbm5lY3Rpb24oZnVuY3Rpb24gKGVyciwgc2VjdXJlZCkge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICB0aGlzLl9vbkVycm9yKG5ldyBFcnJvcignRXJyb3IgaW5pdGlhdGluZyBUTFMgLSAnICsgKGVyci5tZXNzYWdlIHx8IGVycikpLCAnRVRMUycsIGZhbHNlLCAnU1RBUlRUTFMnKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMubG9nZ2VyLmluZm8oJ1slc10gQ29ubmVjdGlvbiB1cGdyYWRlZCB3aXRoIFNUQVJUVExTJywgdGhpcy5pZCk7XG5cbiAgICAgICAgaWYgKHNlY3VyZWQpIHtcbiAgICAgICAgICAgIC8vIHJlc3RhcnQgc2Vzc2lvblxuICAgICAgICAgICAgdGhpcy5fcmVzcG9uc2VBY3Rpb25zLnB1c2godGhpcy5fYWN0aW9uRUhMTyk7XG4gICAgICAgICAgICB0aGlzLl9zZW5kQ29tbWFuZCgnRUhMTyAnICsgdGhpcy5uYW1lKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnY29ubmVjdCcpO1xuICAgICAgICB9XG4gICAgfS5iaW5kKHRoaXMpKTtcbn07XG5cbi8qKlxuICogSGFuZGxlIHRoZSByZXNwb25zZSBmb3IgQVVUSCBMT0dJTiBjb21tYW5kLiBXZSBhcmUgZXhwZWN0aW5nXG4gKiAnMzM0IFZYTmxjbTVoYldVNicgKGJhc2U2NCBmb3IgJ1VzZXJuYW1lOicpLiBEYXRhIHRvIGJlIHNlbnQgYXNcbiAqIHJlc3BvbnNlIG5lZWRzIHRvIGJlIGJhc2U2NCBlbmNvZGVkIHVzZXJuYW1lLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgTWVzc2FnZSBmcm9tIHRoZSBzZXJ2ZXJcbiAqL1xuU01UUENvbm5lY3Rpb24ucHJvdG90eXBlLl9hY3Rpb25BVVRIX0xPR0lOX1VTRVIgPSBmdW5jdGlvbiAoc3RyLCBjYWxsYmFjaykge1xuICAgIGlmIChzdHIgIT09ICczMzQgVlhObGNtNWhiV1U2Jykge1xuICAgICAgICBjYWxsYmFjayh0aGlzLl9mb3JtYXRFcnJvcignSW52YWxpZCBsb2dpbiBzZXF1ZW5jZSB3aGlsZSB3YWl0aW5nIGZvciBcIjMzNCBWWE5sY201aGJXVTZcIicsICdFQVVUSCcsIHN0ciwgJ0FVVEggTE9HSU4nKSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLl9yZXNwb25zZUFjdGlvbnMucHVzaChmdW5jdGlvbiAoc3RyKSB7XG4gICAgICAgIHRoaXMuX2FjdGlvbkFVVEhfTE9HSU5fUEFTUyhzdHIsIGNhbGxiYWNrKTtcbiAgICB9LmJpbmQodGhpcykpO1xuXG4gICAgdGhpcy5fc2VuZENvbW1hbmQobmV3IEJ1ZmZlcih0aGlzLl9hdXRoLnVzZXIgKyAnJywgJ3V0Zi04JykudG9TdHJpbmcoJ2Jhc2U2NCcpKTtcbn07XG5cbi8qKlxuICogSGFuZGxlIHRoZSByZXNwb25zZSBmb3IgQVVUSCBOVExNLCB3aGljaCBzaG91bGQgYmUgYVxuICogJzMzNCA8Y2hhbGxlbmdlIHN0cmluZz4nLiBTZWUgaHR0cDovL2RhdmVucG9ydC5zb3VyY2Vmb3JnZS5uZXQvbnRsbS5odG1sXG4gKiBXZSBhbHJlYWR5IHNlbnQgdGhlIFR5cGUxIG1lc3NhZ2UsIHRoZSBjaGFsbGVuZ2UgaXMgYSBUeXBlMiBtZXNzYWdlLCB3ZVxuICogbmVlZCB0byByZXNwb25kIHdpdGggYSBUeXBlMyBtZXNzYWdlLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgTWVzc2FnZSBmcm9tIHRoZSBzZXJ2ZXJcbiAqL1xuU01UUENvbm5lY3Rpb24ucHJvdG90eXBlLl9hY3Rpb25BVVRIX05UTE1fVFlQRTEgPSBmdW5jdGlvbiAoc3RyLCBjYWxsYmFjaykge1xuICAgIHZhciBjaGFsbGVuZ2VNYXRjaCA9IHN0ci5tYXRjaCgvXjMzNFxccysoLispJC8pO1xuICAgIHZhciBjaGFsbGVuZ2VTdHJpbmcgPSAnJztcblxuICAgIGlmICghY2hhbGxlbmdlTWF0Y2gpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKHRoaXMuX2Zvcm1hdEVycm9yKCdJbnZhbGlkIGxvZ2luIHNlcXVlbmNlIHdoaWxlIHdhaXRpbmcgZm9yIHNlcnZlciBjaGFsbGVuZ2Ugc3RyaW5nJywgJ0VBVVRIJywgc3RyLCAnQVVUSCBOVExNJykpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGNoYWxsZW5nZVN0cmluZyA9IGNoYWxsZW5nZU1hdGNoWzFdO1xuICAgIH1cblxuICAgIGlmICghL15OVExNL2kudGVzdChjaGFsbGVuZ2VTdHJpbmcpKSB7XG4gICAgICAgIGNoYWxsZW5nZVN0cmluZyA9ICdOVExNICcgKyBjaGFsbGVuZ2VTdHJpbmc7XG4gICAgfVxuXG4gICAgdmFyIHR5cGUyTWVzc2FnZSA9IG50bG0ucGFyc2VUeXBlMk1lc3NhZ2UoY2hhbGxlbmdlU3RyaW5nLCBjYWxsYmFjayk7XG4gICAgaWYgKCF0eXBlMk1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciB0eXBlM01lc3NhZ2UgPSBudGxtLmNyZWF0ZVR5cGUzTWVzc2FnZSh0eXBlMk1lc3NhZ2UsIHtcbiAgICAgICAgZG9tYWluOiB0aGlzLl9hdXRoLmRvbWFpbiB8fCAnJyxcbiAgICAgICAgd29ya3N0YXRpb246IHRoaXMuX2F1dGgud29ya3N0YXRpb24gfHwgJycsXG4gICAgICAgIHVzZXJuYW1lOiB0aGlzLl9hdXRoLnVzZXIsXG4gICAgICAgIHBhc3N3b3JkOiB0aGlzLl9hdXRoLnBhc3NcbiAgICB9KTtcblxuICAgIHR5cGUzTWVzc2FnZSA9IHR5cGUzTWVzc2FnZS5zdWJzdHJpbmcoNSk7IC8vIHJlbW92ZSB0aGUgXCJOVExNIFwiIHByZWZpeFxuXG4gICAgdGhpcy5fcmVzcG9uc2VBY3Rpb25zLnB1c2goZnVuY3Rpb24gKHN0cikge1xuICAgICAgICB0aGlzLl9hY3Rpb25BVVRIX05UTE1fVFlQRTMoc3RyLCBjYWxsYmFjayk7XG4gICAgfS5iaW5kKHRoaXMpKTtcblxuICAgIHRoaXMuX3NlbmRDb21tYW5kKHR5cGUzTWVzc2FnZSk7XG59O1xuXG4vKipcbiAqIEhhbmRsZSB0aGUgcmVzcG9uc2UgZm9yIEFVVEggQ1JBTS1NRDUgY29tbWFuZC4gV2UgYXJlIGV4cGVjdGluZ1xuICogJzMzNCA8Y2hhbGxlbmdlIHN0cmluZz4nLiBEYXRhIHRvIGJlIHNlbnQgYXMgcmVzcG9uc2UgbmVlZHMgdG8gYmVcbiAqIGJhc2U2NCBkZWNvZGVkIGNoYWxsZW5nZSBzdHJpbmcsIE1ENSBoYXNoZWQgdXNpbmcgdGhlIHBhc3N3b3JkIGFzXG4gKiBhIEhNQUMga2V5LCBwcmVmaXhlZCBieSB0aGUgdXNlcm5hbWUgYW5kIGEgc3BhY2UsIGFuZCBmaW5hbGx5IGFsbFxuICogYmFzZTY0IGVuY29kZWQgYWdhaW4uXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0ciBNZXNzYWdlIGZyb20gdGhlIHNlcnZlclxuICovXG5TTVRQQ29ubmVjdGlvbi5wcm90b3R5cGUuX2FjdGlvbkFVVEhfQ1JBTV9NRDUgPSBmdW5jdGlvbiAoc3RyLCBjYWxsYmFjaykge1xuICAgIHZhciBjaGFsbGVuZ2VNYXRjaCA9IHN0ci5tYXRjaCgvXjMzNFxccysoLispJC8pO1xuICAgIHZhciBjaGFsbGVuZ2VTdHJpbmcgPSAnJztcblxuICAgIGlmICghY2hhbGxlbmdlTWF0Y2gpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKHRoaXMuX2Zvcm1hdEVycm9yKCdJbnZhbGlkIGxvZ2luIHNlcXVlbmNlIHdoaWxlIHdhaXRpbmcgZm9yIHNlcnZlciBjaGFsbGVuZ2Ugc3RyaW5nJywgJ0VBVVRIJywgc3RyLCAnQVVUSCBDUkFNLU1ENScpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBjaGFsbGVuZ2VTdHJpbmcgPSBjaGFsbGVuZ2VNYXRjaFsxXTtcbiAgICB9XG5cbiAgICAvLyBEZWNvZGUgZnJvbSBiYXNlNjRcbiAgICB2YXIgYmFzZTY0ZGVjb2RlZCA9IG5ldyBCdWZmZXIoY2hhbGxlbmdlU3RyaW5nLCAnYmFzZTY0JykudG9TdHJpbmcoJ2FzY2lpJyksXG4gICAgICAgIGhtYWNfbWQ1ID0gY3J5cHRvLmNyZWF0ZUhtYWMoJ21kNScsIHRoaXMuX2F1dGgucGFzcyk7XG5cbiAgICBobWFjX21kNS51cGRhdGUoYmFzZTY0ZGVjb2RlZCk7XG5cbiAgICB2YXIgaGV4X2htYWMgPSBobWFjX21kNS5kaWdlc3QoJ2hleCcpLFxuICAgICAgICBwcmVwZW5kZWQgPSB0aGlzLl9hdXRoLnVzZXIgKyAnICcgKyBoZXhfaG1hYztcblxuICAgIHRoaXMuX3Jlc3BvbnNlQWN0aW9ucy5wdXNoKGZ1bmN0aW9uIChzdHIpIHtcbiAgICAgICAgdGhpcy5fYWN0aW9uQVVUSF9DUkFNX01ENV9QQVNTKHN0ciwgY2FsbGJhY2spO1xuICAgIH0uYmluZCh0aGlzKSk7XG5cblxuICAgIHRoaXMuX3NlbmRDb21tYW5kKG5ldyBCdWZmZXIocHJlcGVuZGVkKS50b1N0cmluZygnYmFzZTY0JykpO1xufTtcblxuLyoqXG4gKiBIYW5kbGVzIHRoZSByZXNwb25zZSB0byBDUkFNLU1ENSBhdXRoZW50aWNhdGlvbiwgaWYgdGhlcmUncyBubyBlcnJvcixcbiAqIHRoZSB1c2VyIGNhbiBiZSBjb25zaWRlcmVkIGxvZ2dlZCBpbi4gU3RhcnQgd2FpdGluZyBmb3IgYSBtZXNzYWdlIHRvIHNlbmRcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyIE1lc3NhZ2UgZnJvbSB0aGUgc2VydmVyXG4gKi9cblNNVFBDb25uZWN0aW9uLnByb3RvdHlwZS5fYWN0aW9uQVVUSF9DUkFNX01ENV9QQVNTID0gZnVuY3Rpb24gKHN0ciwgY2FsbGJhY2spIHtcbiAgICBpZiAoIXN0ci5tYXRjaCgvXjIzNVxccysvKSkge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2sodGhpcy5fZm9ybWF0RXJyb3IoJ0ludmFsaWQgbG9naW4gc2VxdWVuY2Ugd2hpbGUgd2FpdGluZyBmb3IgXCIyMzVcIicsICdFQVVUSCcsIHN0ciwgJ0FVVEggQ1JBTS1NRDUnKSk7XG4gICAgfVxuXG4gICAgdGhpcy5sb2dnZXIuaW5mbygnWyVzXSBVc2VyICVzIGF1dGhlbnRpY2F0ZWQnLCB0aGlzLmlkLCBKU09OLnN0cmluZ2lmeSh0aGlzLl91c2VyKSk7XG4gICAgdGhpcy5hdXRoZW50aWNhdGVkID0gdHJ1ZTtcbiAgICBjYWxsYmFjayhudWxsLCB0cnVlKTtcbn07XG5cbi8qKlxuICogSGFuZGxlcyB0aGUgVFlQRTMgcmVzcG9uc2UgZm9yIE5UTE0gYXV0aGVudGljYXRpb24sIGlmIHRoZXJlJ3Mgbm8gZXJyb3IsXG4gKiB0aGUgdXNlciBjYW4gYmUgY29uc2lkZXJlZCBsb2dnZWQgaW4uIFN0YXJ0IHdhaXRpbmcgZm9yIGEgbWVzc2FnZSB0byBzZW5kXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0ciBNZXNzYWdlIGZyb20gdGhlIHNlcnZlclxuICovXG5TTVRQQ29ubmVjdGlvbi5wcm90b3R5cGUuX2FjdGlvbkFVVEhfTlRMTV9UWVBFMyA9IGZ1bmN0aW9uIChzdHIsIGNhbGxiYWNrKSB7XG4gICAgaWYgKCFzdHIubWF0Y2goL14yMzVcXHMrLykpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKHRoaXMuX2Zvcm1hdEVycm9yKCdJbnZhbGlkIGxvZ2luIHNlcXVlbmNlIHdoaWxlIHdhaXRpbmcgZm9yIFwiMjM1XCInLCAnRUFVVEgnLCBzdHIsICdBVVRIIE5UTE0nKSk7XG4gICAgfVxuXG4gICAgdGhpcy5sb2dnZXIuaW5mbygnWyVzXSBVc2VyICVzIGF1dGhlbnRpY2F0ZWQnLCB0aGlzLmlkLCBKU09OLnN0cmluZ2lmeSh0aGlzLl91c2VyKSk7XG4gICAgdGhpcy5hdXRoZW50aWNhdGVkID0gdHJ1ZTtcbiAgICBjYWxsYmFjayhudWxsLCB0cnVlKTtcbn07XG5cbi8qKlxuICogSGFuZGxlIHRoZSByZXNwb25zZSBmb3IgQVVUSCBMT0dJTiBjb21tYW5kLiBXZSBhcmUgZXhwZWN0aW5nXG4gKiAnMzM0IFVHRnpjM2R2Y21RNicgKGJhc2U2NCBmb3IgJ1Bhc3N3b3JkOicpLiBEYXRhIHRvIGJlIHNlbnQgYXNcbiAqIHJlc3BvbnNlIG5lZWRzIHRvIGJlIGJhc2U2NCBlbmNvZGVkIHBhc3N3b3JkLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgTWVzc2FnZSBmcm9tIHRoZSBzZXJ2ZXJcbiAqL1xuU01UUENvbm5lY3Rpb24ucHJvdG90eXBlLl9hY3Rpb25BVVRIX0xPR0lOX1BBU1MgPSBmdW5jdGlvbiAoc3RyLCBjYWxsYmFjaykge1xuICAgIGlmIChzdHIgIT09ICczMzQgVUdGemMzZHZjbVE2Jykge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2sodGhpcy5fZm9ybWF0RXJyb3IoJ0ludmFsaWQgbG9naW4gc2VxdWVuY2Ugd2hpbGUgd2FpdGluZyBmb3IgXCIzMzQgVUdGemMzZHZjbVE2XCInLCAnRUFVVEgnLCBzdHIsICdBVVRIIExPR0lOJykpO1xuICAgIH1cblxuICAgIHRoaXMuX3Jlc3BvbnNlQWN0aW9ucy5wdXNoKGZ1bmN0aW9uIChzdHIpIHtcbiAgICAgICAgdGhpcy5fYWN0aW9uQVVUSENvbXBsZXRlKHN0ciwgY2FsbGJhY2spO1xuICAgIH0uYmluZCh0aGlzKSk7XG5cbiAgICB0aGlzLl9zZW5kQ29tbWFuZChuZXcgQnVmZmVyKHRoaXMuX2F1dGgucGFzcyArICcnLCAndXRmLTgnKS50b1N0cmluZygnYmFzZTY0JykpO1xufTtcblxuLyoqXG4gKiBIYW5kbGVzIHRoZSByZXNwb25zZSBmb3IgYXV0aGVudGljYXRpb24sIGlmIHRoZXJlJ3Mgbm8gZXJyb3IsXG4gKiB0aGUgdXNlciBjYW4gYmUgY29uc2lkZXJlZCBsb2dnZWQgaW4uIFN0YXJ0IHdhaXRpbmcgZm9yIGEgbWVzc2FnZSB0byBzZW5kXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0ciBNZXNzYWdlIGZyb20gdGhlIHNlcnZlclxuICovXG5TTVRQQ29ubmVjdGlvbi5wcm90b3R5cGUuX2FjdGlvbkFVVEhDb21wbGV0ZSA9IGZ1bmN0aW9uIChzdHIsIGlzUmV0cnksIGNhbGxiYWNrKSB7XG4gICAgaWYgKCFjYWxsYmFjayAmJiB0eXBlb2YgaXNSZXRyeSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBjYWxsYmFjayA9IGlzUmV0cnk7XG4gICAgICAgIGlzUmV0cnkgPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgaWYgKHN0ci5zdWJzdHIoMCwgMykgPT09ICczMzQnKSB7XG4gICAgICAgIHRoaXMuX3Jlc3BvbnNlQWN0aW9ucy5wdXNoKGZ1bmN0aW9uIChzdHIpIHtcbiAgICAgICAgICAgIGlmIChpc1JldHJ5IHx8ICF0aGlzLl9hdXRoLnhvYXV0aDIgfHwgdHlwZW9mIHRoaXMuX2F1dGgueG9hdXRoMiAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9hY3Rpb25BVVRIQ29tcGxldGUoc3RyLCB0cnVlLCBjYWxsYmFjayk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQodGhpcy5faGFuZGxlWE9hdXRoMlRva2VuLmJpbmQodGhpcywgdHJ1ZSwgY2FsbGJhY2spLCBNYXRoLnJhbmRvbSgpICogNDAwMCArIDEwMDApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLl9zZW5kQ29tbWFuZCgnJyk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoc3RyLmNoYXJBdCgwKSAhPT0gJzInKSB7XG4gICAgICAgIHRoaXMubG9nZ2VyLmluZm8oJ1slc10gVXNlciAlcyBmYWlsZWQgdG8gYXV0aGVudGljYXRlJywgdGhpcy5pZCwgSlNPTi5zdHJpbmdpZnkodGhpcy5fdXNlcikpO1xuICAgICAgICByZXR1cm4gY2FsbGJhY2sodGhpcy5fZm9ybWF0RXJyb3IoJ0ludmFsaWQgbG9naW4nLCAnRUFVVEgnLCBzdHIsICdBVVRIICcgKyB0aGlzLl9hdXRoTWV0aG9kKSk7XG4gICAgfVxuXG4gICAgdGhpcy5sb2dnZXIuaW5mbygnWyVzXSBVc2VyICVzIGF1dGhlbnRpY2F0ZWQnLCB0aGlzLmlkLCBKU09OLnN0cmluZ2lmeSh0aGlzLl91c2VyKSk7XG4gICAgdGhpcy5hdXRoZW50aWNhdGVkID0gdHJ1ZTtcbiAgICBjYWxsYmFjayhudWxsLCB0cnVlKTtcbn07XG5cbi8qKlxuICogSGFuZGxlIHJlc3BvbnNlIGZvciBhIE1BSUwgRlJPTTogY29tbWFuZFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgTWVzc2FnZSBmcm9tIHRoZSBzZXJ2ZXJcbiAqL1xuU01UUENvbm5lY3Rpb24ucHJvdG90eXBlLl9hY3Rpb25NQUlMID0gZnVuY3Rpb24gKHN0ciwgY2FsbGJhY2spIHtcbiAgICB2YXIgbWVzc2FnZSwgY3VyUmVjaXBpZW50O1xuICAgIGlmIChOdW1iZXIoc3RyLmNoYXJBdCgwKSkgIT09IDIpIHtcbiAgICAgICAgaWYgKHRoaXMuX3VzaW5nU210cFV0ZjggJiYgL141NTAgLy50ZXN0KHN0cikgJiYgL1tcXHg4MC1cXHVGRkZGXS8udGVzdCh0aGlzLl9lbnZlbG9wZS5mcm9tKSkge1xuICAgICAgICAgICAgbWVzc2FnZSA9ICdJbnRlcm5hdGlvbmFsaXplZCBtYWlsYm94IG5hbWUgbm90IGFsbG93ZWQnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWVzc2FnZSA9ICdNYWlsIGNvbW1hbmQgZmFpbGVkJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2FsbGJhY2sodGhpcy5fZm9ybWF0RXJyb3IobWVzc2FnZSwgJ0VFTlZFTE9QRScsIHN0ciwgJ01BSUwgRlJPTScpKTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuX2VudmVsb3BlLnJjcHRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKHRoaXMuX2Zvcm1hdEVycm9yKCdDYW5cXCd0IHNlbmQgbWFpbCAtIG5vIHJlY2lwaWVudHMgZGVmaW5lZCcsICdFRU5WRUxPUEUnLCBmYWxzZSwgJ0FQSScpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9yZWNpcGllbnRRdWV1ZSA9IFtdO1xuXG4gICAgICAgIGlmICh0aGlzLl9zdXBwb3J0ZWRFeHRlbnNpb25zLmluZGV4T2YoJ1BJUEVMSU5JTkcnKSA+PSAwKSB7XG4gICAgICAgICAgICB3aGlsZSAodGhpcy5fZW52ZWxvcGUucmNwdFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGN1clJlY2lwaWVudCA9IHRoaXMuX2VudmVsb3BlLnJjcHRRdWV1ZS5zaGlmdCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlY2lwaWVudFF1ZXVlLnB1c2goY3VyUmVjaXBpZW50KTtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZXNwb25zZUFjdGlvbnMucHVzaChmdW5jdGlvbiAoc3RyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2FjdGlvblJDUFQoc3RyLCBjYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9zZW5kQ29tbWFuZCgnUkNQVCBUTzo8JyArIGN1clJlY2lwaWVudCArICc+JyArIHRoaXMuX2dldERzblJjcHRUb0FyZ3MoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjdXJSZWNpcGllbnQgPSB0aGlzLl9lbnZlbG9wZS5yY3B0UXVldWUuc2hpZnQoKTtcbiAgICAgICAgICAgIHRoaXMuX3JlY2lwaWVudFF1ZXVlLnB1c2goY3VyUmVjaXBpZW50KTtcbiAgICAgICAgICAgIHRoaXMuX3Jlc3BvbnNlQWN0aW9ucy5wdXNoKGZ1bmN0aW9uIChzdHIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9hY3Rpb25SQ1BUKHN0ciwgY2FsbGJhY2spO1xuICAgICAgICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICAgICAgICAgIHRoaXMuX3NlbmRDb21tYW5kKCdSQ1BUIFRPOjwnICsgY3VyUmVjaXBpZW50ICsgJz4nICsgdGhpcy5fZ2V0RHNuUmNwdFRvQXJncygpKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbi8qKlxuICogSGFuZGxlIHJlc3BvbnNlIGZvciBhIFJDUFQgVE86IGNvbW1hbmRcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyIE1lc3NhZ2UgZnJvbSB0aGUgc2VydmVyXG4gKi9cblNNVFBDb25uZWN0aW9uLnByb3RvdHlwZS5fYWN0aW9uUkNQVCA9IGZ1bmN0aW9uIChzdHIsIGNhbGxiYWNrKSB7XG4gICAgdmFyIG1lc3NhZ2UsIGVyciwgY3VyUmVjaXBpZW50ID0gdGhpcy5fcmVjaXBpZW50UXVldWUuc2hpZnQoKTtcbiAgICBpZiAoTnVtYmVyKHN0ci5jaGFyQXQoMCkpICE9PSAyKSB7XG4gICAgICAgIC8vIHRoaXMgaXMgYSBzb2Z0IGVycm9yXG4gICAgICAgIGlmICh0aGlzLl91c2luZ1NtdHBVdGY4ICYmIC9eNTUzIC8udGVzdChzdHIpICYmIC9bXFx4ODAtXFx1RkZGRl0vLnRlc3QoY3VyUmVjaXBpZW50KSkge1xuICAgICAgICAgICAgbWVzc2FnZSA9ICdJbnRlcm5hdGlvbmFsaXplZCBtYWlsYm94IG5hbWUgbm90IGFsbG93ZWQnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWVzc2FnZSA9ICdSZWNpcGllbnQgY29tbWFuZCBmYWlsZWQnO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2VudmVsb3BlLnJlamVjdGVkLnB1c2goY3VyUmVjaXBpZW50KTtcbiAgICAgICAgLy8gc3RvcmUgZXJyb3IgZm9yIHRoZSBmYWlsZWQgcmVjaXBpZW50XG4gICAgICAgIGVyciA9IHRoaXMuX2Zvcm1hdEVycm9yKG1lc3NhZ2UsICdFRU5WRUxPUEUnLCBzdHIsICdSQ1BUIFRPJyk7XG4gICAgICAgIGVyci5yZWNpcGllbnQgPSBjdXJSZWNpcGllbnQ7XG4gICAgICAgIHRoaXMuX2VudmVsb3BlLnJlamVjdGVkRXJyb3JzLnB1c2goZXJyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9lbnZlbG9wZS5hY2NlcHRlZC5wdXNoKGN1clJlY2lwaWVudCk7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLl9lbnZlbG9wZS5yY3B0UXVldWUubGVuZ3RoICYmICF0aGlzLl9yZWNpcGllbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2VudmVsb3BlLnJlamVjdGVkLmxlbmd0aCA8IHRoaXMuX2VudmVsb3BlLnRvLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5fcmVzcG9uc2VBY3Rpb25zLnB1c2goZnVuY3Rpb24gKHN0cikge1xuICAgICAgICAgICAgICAgIHRoaXMuX2FjdGlvbkRBVEEoc3RyLCBjYWxsYmFjayk7XG4gICAgICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgICAgICAgICAgdGhpcy5fc2VuZENvbW1hbmQoJ0RBVEEnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVyciA9IHRoaXMuX2Zvcm1hdEVycm9yKCdDYW5cXCd0IHNlbmQgbWFpbCAtIGFsbCByZWNpcGllbnRzIHdlcmUgcmVqZWN0ZWQnLCAnRUVOVkVMT1BFJywgc3RyLCAnUkNQVCBUTycpO1xuICAgICAgICAgICAgZXJyLnJlamVjdGVkID0gdGhpcy5fZW52ZWxvcGUucmVqZWN0ZWQ7XG4gICAgICAgICAgICBlcnIucmVqZWN0ZWRFcnJvcnMgPSB0aGlzLl9lbnZlbG9wZS5yZWplY3RlZEVycm9ycztcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIGlmICh0aGlzLl9lbnZlbG9wZS5yY3B0UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGN1clJlY2lwaWVudCA9IHRoaXMuX2VudmVsb3BlLnJjcHRRdWV1ZS5zaGlmdCgpO1xuICAgICAgICB0aGlzLl9yZWNpcGllbnRRdWV1ZS5wdXNoKGN1clJlY2lwaWVudCk7XG4gICAgICAgIHRoaXMuX3Jlc3BvbnNlQWN0aW9ucy5wdXNoKGZ1bmN0aW9uIChzdHIpIHtcbiAgICAgICAgICAgIHRoaXMuX2FjdGlvblJDUFQoc3RyLCBjYWxsYmFjayk7XG4gICAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMuX3NlbmRDb21tYW5kKCdSQ1BUIFRPOjwnICsgY3VyUmVjaXBpZW50ICsgJz4nICsgdGhpcy5fZ2V0RHNuUmNwdFRvQXJncygpKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIEhhbmRsZSByZXNwb25zZSBmb3IgYSBEQVRBIGNvbW1hbmRcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyIE1lc3NhZ2UgZnJvbSB0aGUgc2VydmVyXG4gKi9cblNNVFBDb25uZWN0aW9uLnByb3RvdHlwZS5fYWN0aW9uREFUQSA9IGZ1bmN0aW9uIChzdHIsIGNhbGxiYWNrKSB7XG4gICAgLy8gcmVzcG9uc2Ugc2hvdWxkIGJlIDM1NCBidXQgYWNjb3JkaW5nIHRvIHRoaXMgaXNzdWUgaHR0cHM6Ly9naXRodWIuY29tL2VsZWl0aC9lbWFpbGpzL2lzc3Vlcy8yNFxuICAgIC8vIHNvbWUgc2VydmVycyBtaWdodCB1c2UgMjUwIGluc3RlYWQsIHNvIGxldHMgY2hlY2sgZm9yIDIgb3IgMyBhcyB0aGUgZmlyc3QgZGlnaXRcbiAgICBpZiAoWzIsIDNdLmluZGV4T2YoTnVtYmVyKHN0ci5jaGFyQXQoMCkpKSA8IDApIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKHRoaXMuX2Zvcm1hdEVycm9yKCdEYXRhIGNvbW1hbmQgZmFpbGVkJywgJ0VFTlZFTE9QRScsIHN0ciwgJ0RBVEEnKSk7XG4gICAgfVxuXG4gICAgdmFyIHJlc3BvbnNlID0ge1xuICAgICAgICBhY2NlcHRlZDogdGhpcy5fZW52ZWxvcGUuYWNjZXB0ZWQsXG4gICAgICAgIHJlamVjdGVkOiB0aGlzLl9lbnZlbG9wZS5yZWplY3RlZFxuICAgIH07XG5cbiAgICBpZiAodGhpcy5fZW52ZWxvcGUucmVqZWN0ZWRFcnJvcnMubGVuZ3RoKSB7XG4gICAgICAgIHJlc3BvbnNlLnJlamVjdGVkRXJyb3JzID0gdGhpcy5fZW52ZWxvcGUucmVqZWN0ZWRFcnJvcnM7XG4gICAgfVxuXG4gICAgY2FsbGJhY2sobnVsbCwgcmVzcG9uc2UpO1xufTtcblxuLyoqXG4gKiBIYW5kbGUgcmVzcG9uc2UgZm9yIGEgREFUQSBzdHJlYW0gd2hlbiB1c2luZyBTTVRQXG4gKiBXZSBleHBlY3QgYSBzaW5nbGUgcmVzcG9uc2UgdGhhdCBkZWZpbmVzIGlmIHRoZSBzZW5kaW5nIHN1Y2NlZWRlZCBvciBmYWlsZWRcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyIE1lc3NhZ2UgZnJvbSB0aGUgc2VydmVyXG4gKi9cblNNVFBDb25uZWN0aW9uLnByb3RvdHlwZS5fYWN0aW9uU01UUFN0cmVhbSA9IGZ1bmN0aW9uIChzdHIsIGNhbGxiYWNrKSB7XG4gICAgaWYgKE51bWJlcihzdHIuY2hhckF0KDApKSAhPT0gMikge1xuICAgICAgICAvLyBNZXNzYWdlIGZhaWxlZFxuICAgICAgICByZXR1cm4gY2FsbGJhY2sodGhpcy5fZm9ybWF0RXJyb3IoJ01lc3NhZ2UgZmFpbGVkJywgJ0VNRVNTQUdFJywgc3RyLCAnREFUQScpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBNZXNzYWdlIHNlbnQgc3VjY2VzZnVsbHlcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIHN0cik7XG4gICAgfVxufTtcblxuLyoqXG4gKiBIYW5kbGUgcmVzcG9uc2UgZm9yIGEgREFUQSBzdHJlYW1cbiAqIFdlIGV4cGVjdCBhIHNlcGFyYXRlIHJlc3BvbnNlIGZvciBldmVyeSByZWNpcGllbnQuIEFsbCByZWNpcGllbnRzIGNhbiBlaXRoZXJcbiAqIHN1Y2NlZWQgb3IgZmFpbCBzZXBhcmF0ZWx5XG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHJlY2lwaWVudCBUaGUgcmVjaXBpZW50IHRoaXMgcmVzcG9uc2UgYXBwbGllcyB0b1xuICogQHBhcmFtIHtCb29sZWFufSBmaW5hbCBJcyB0aGlzIHRoZSBmaW5hbCByZWNpcGllbnQ/XG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyIE1lc3NhZ2UgZnJvbSB0aGUgc2VydmVyXG4gKi9cblNNVFBDb25uZWN0aW9uLnByb3RvdHlwZS5fYWN0aW9uTE1UUFN0cmVhbSA9IGZ1bmN0aW9uIChyZWNpcGllbnQsIGZpbmFsLCBzdHIsIGNhbGxiYWNrKSB7XG4gICAgdmFyIGVycjtcbiAgICBpZiAoTnVtYmVyKHN0ci5jaGFyQXQoMCkpICE9PSAyKSB7XG4gICAgICAgIC8vIE1lc3NhZ2UgZmFpbGVkXG4gICAgICAgIGVyciA9IHRoaXMuX2Zvcm1hdEVycm9yKCdNZXNzYWdlIGZhaWxlZCBmb3IgcmVjaXBpZW50ICcgKyByZWNpcGllbnQsICdFTUVTU0FHRScsIHN0ciwgJ0RBVEEnKTtcbiAgICAgICAgZXJyLnJlY2lwaWVudCA9IHJlY2lwaWVudDtcbiAgICAgICAgdGhpcy5fZW52ZWxvcGUucmVqZWN0ZWQucHVzaChyZWNpcGllbnQpO1xuICAgICAgICB0aGlzLl9lbnZlbG9wZS5yZWplY3RlZEVycm9ycy5wdXNoKGVycik7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLl9lbnZlbG9wZS5hY2NlcHRlZC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2VudmVsb3BlLmFjY2VwdGVkW2ldID09PSByZWNpcGllbnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9lbnZlbG9wZS5hY2NlcHRlZC5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGZpbmFsKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCBzdHIpO1xuICAgIH1cbn07XG5cblNNVFBDb25uZWN0aW9uLnByb3RvdHlwZS5faGFuZGxlWE9hdXRoMlRva2VuID0gZnVuY3Rpb24gKGlzUmV0cnksIGNhbGxiYWNrKSB7XG4gICAgdGhpcy5fcmVzcG9uc2VBY3Rpb25zLnB1c2goZnVuY3Rpb24gKHN0cikge1xuICAgICAgICB0aGlzLl9hY3Rpb25BVVRIQ29tcGxldGUoc3RyLCBpc1JldHJ5LCBjYWxsYmFjayk7XG4gICAgfS5iaW5kKHRoaXMpKTtcblxuICAgIGlmICh0aGlzLl9hdXRoLnhvYXV0aDIgJiYgdHlwZW9mIHRoaXMuX2F1dGgueG9hdXRoMiA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgdGhpcy5fYXV0aC54b2F1dGgyW2lzUmV0cnkgPyAnZ2VuZXJhdGVUb2tlbicgOiAnZ2V0VG9rZW4nXShmdW5jdGlvbiAoZXJyLCB0b2tlbikge1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLmluZm8oJ1slc10gVXNlciAlcyBmYWlsZWQgdG8gYXV0aGVudGljYXRlJywgdGhpcy5pZCwgSlNPTi5zdHJpbmdpZnkodGhpcy5fdXNlcikpO1xuICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayh0aGlzLl9mb3JtYXRFcnJvcihlcnIsICdFQVVUSCcsIGZhbHNlLCAnQVVUSCBYT0FVVEgyJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fc2VuZENvbW1hbmQoJ0FVVEggWE9BVVRIMiAnICsgdG9rZW4pO1xuICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3NlbmRDb21tYW5kKCdBVVRIIFhPQVVUSDIgJyArIHRoaXMuX2J1aWxkWE9BdXRoMlRva2VuKHRoaXMuX2F1dGgudXNlciwgdGhpcy5fYXV0aC54b2F1dGgyKSk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBCdWlsZHMgYSBsb2dpbiB0b2tlbiBmb3IgWE9BVVRIMiBhdXRoZW50aWNhdGlvbiBjb21tYW5kXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHVzZXIgRS1tYWlsIGFkZHJlc3Mgb2YgdGhlIHVzZXJcbiAqIEBwYXJhbSB7U3RyaW5nfSB0b2tlbiBWYWxpZCBhY2Nlc3MgdG9rZW4gZm9yIHRoZSB1c2VyXG4gKiBAcmV0dXJuIHtTdHJpbmd9IEJhc2U2NCBmb3JtYXR0ZWQgbG9naW4gdG9rZW5cbiAqL1xuU01UUENvbm5lY3Rpb24ucHJvdG90eXBlLl9idWlsZFhPQXV0aDJUb2tlbiA9IGZ1bmN0aW9uICh1c2VyLCB0b2tlbikge1xuICAgIHZhciBhdXRoRGF0YSA9IFtcbiAgICAgICAgJ3VzZXI9JyArICh1c2VyIHx8ICcnKSxcbiAgICAgICAgJ2F1dGg9QmVhcmVyICcgKyB0b2tlbixcbiAgICAgICAgJycsXG4gICAgICAgICcnXG4gICAgXTtcbiAgICByZXR1cm4gbmV3IEJ1ZmZlcihhdXRoRGF0YS5qb2luKCdcXHgwMScpKS50b1N0cmluZygnYmFzZTY0Jyk7XG59O1xuXG5TTVRQQ29ubmVjdGlvbi5wcm90b3R5cGUuX2dldEhvc3RuYW1lID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIGRlZmF1bCBob3N0bmFtZSBpcyBtYWNoaW5lIGhvc3RuYW1lIG9yIFtJUF1cbiAgICB2YXIgZGVmYXVsdEhvc3RuYW1lID0gb3MuaG9zdG5hbWUoKSB8fCAnJztcblxuICAgIC8vIGlnbm9yZSBpZiBub3QgRlFETlxuICAgIGlmIChkZWZhdWx0SG9zdG5hbWUuaW5kZXhPZignLicpIDwgMCkge1xuICAgICAgICBkZWZhdWx0SG9zdG5hbWUgPSAnWzEyNy4wLjAuMV0nO1xuICAgIH1cblxuICAgIC8vIElQIHNob3VsZCBiZSBlbmNsb3NlZCBpbiBbXVxuICAgIGlmIChkZWZhdWx0SG9zdG5hbWUubWF0Y2goL15cXGR7MSwzfVxcLlxcZHsxLDN9XFwuXFxkezEsM31cXC5cXGR7MSwzfSQvKSkge1xuICAgICAgICBkZWZhdWx0SG9zdG5hbWUgPSAnWycgKyBkZWZhdWx0SG9zdG5hbWUgKyAnXSc7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRlZmF1bHRIb3N0bmFtZTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/smtp-connection/lib/smtp-connection.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/smtp-connection/package.json":
/*!***************************************************!*\
  !*** ./node_modules/smtp-connection/package.json ***!
  \***************************************************/
/***/ ((module) => {

module.exports = JSON.parse('{"name":"smtp-connection","version":"2.12.0","description":"Connect to SMTP servers","main":"lib/smtp-connection.js","directories":{"test":"test"},"scripts":{"test":"grunt mochaTest"},"repository":{"type":"git","url":"git://github.com/andris9/smtp-connection.git"},"keywords":["SMTP"],"author":"Andris Reinman","license":"MIT","bugs":{"url":"https://github.com/andris9/smtp-connection/issues"},"homepage":"https://github.com/andris9/smtp-connection","devDependencies":{"chai":"^3.5.0","grunt":"^1.0.1","grunt-cli":"^1.2.0","grunt-eslint":"^19.0.0","grunt-mocha-test":"^0.12.7","mocha":"^3.0.2","proxy-test-server":"^1.0.0","sinon":"^1.17.5","smtp-server":"^1.14.2","xoauth2":"^1.2.0"},"dependencies":{"httpntlm":"1.6.1","nodemailer-shared":"1.1.0"}}');

/***/ })

};
;